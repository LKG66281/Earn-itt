<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Tic-Tac-Toe</title>
    <style>
        /* Existing CSS remains the same with minor additions */
        * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-family: 'Arial', sans-serif;
}

body {
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    background: linear-gradient(45deg, #0a001a, #001933, #1a000a);
    background-size: 400%;
    animation: bgGlow 15s ease infinite;
    overflow-x: hidden;
}

@keyframes bgGlow {
    0% { background-position: 0% 50%; }
    50% { background-position: 400% 50%; }
    100% { background-position: 0% 50%; }
}

.container {
    background: rgba(0, 0, 0, 0.9);
    padding: 5%;
    border-radius: 10px;
    box-shadow: 0 0 30px rgba(195, 0, 255, 0.8), 0 0 50px rgba(0, 230, 230, 0.8);
    width: min(90%, 500px);
    text-align: center;
    position: relative;
    z-index: 1;
}

h2 {
    color: #c300ff;
    text-shadow: 0 0 15px #c300ff, 0 0 25px #00e6e6;
    margin-bottom: 5%;
    font-size: clamp(1.5rem, 5vw, 2rem);
}

.input-box {
    margin-bottom: 5%;
    width: 80%;
    margin-left: auto;
    margin-right: auto;
}

input[type="text"], input[type="file"], input[type="email"], input[type="password"] {
    width: 100%;
    padding: 3%;
    background: rgba(255, 255, 255, 0.1);
    border: none;
    outline: none;
    border-radius: 25px;
    color: #fff;
    font-size: clamp(0.9rem, 3vw, 1rem);
    box-shadow: 0 0 10px rgba(0, 230, 230, 0.6);
    transition: box-shadow 0.3s ease;
}

input[type="file"] {
    display: none;
}

input:focus {
    box-shadow: 0 0 25px #c300ff, 0 0 35px #00e6e6;
}

button {
    width: 100%;
    padding: 3%;
    background: linear-gradient(45deg, #c300ff, #00e6e6);
    background-size: 200%;
    border: none;
    border-radius: 5px;
    color: #000;
    font-size: clamp(0.9rem, 3vw, 1rem);
    cursor: pointer;
    text-shadow: 0 0 5px #fff;
    box-shadow: 0 0 15px rgba(195, 0, 255, 0.8);
    transition: all 0.3s ease;
    margin-bottom: 3%;
    animation: pulseButton 2s infinite;
}

@keyframes pulseButton {
    0% { background-position: 0% 50%; }
    50% { background-position: 200% 50%; }
    100% { background-position: 0% 50%; }
}

button:hover {
    box-shadow: 0 0 35px #c300ff, 0 0 55px #00e6e6;
    color: #fff;
}

.toggle-text {
    color: #00e6e6;
    cursor: pointer;
    margin-top: 3%;
    display: inline-block;
    text-shadow: 0 0 5px #00e6e6;
    font-size: clamp(0.8rem, 2.5vw, 0.9rem);
}

.toggle-text:hover {
    text-decoration: underline;
    text-shadow: 0 0 15px #c300ff;
}

.message {
    position: fixed;
    top: 5%;
    right: 5%;
    padding: 3%;
    border-radius: 5px;
    color: #fff;
    font-size: clamp(0.8rem, 2.5vw, 0.9rem);
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
    opacity: 0;
    transition: opacity 0.3s ease;
    z-index: 1000;
}

.message.success {
    background: #33ff66;
    text-shadow: 0 0 5px #33ff66;
}

.message.error {
    background: #ff5733;
    text-shadow: 0 0 5px #ff5733;
}

.dashboard, .game-page, .game-room, .waiting-area, .profile-page {
    display: none;
    color: #fff;
}

.play-btn {
    background: linear-gradient(45deg, #ff5733, #c300ff);
    box-shadow: 0 0 15px rgba(255, 87, 51, 0.8);
}

.play-btn:hover {
    box-shadow: 0 0 35px #ff5733, 0 0 55px #c300ff;
}

.circle-btn {
    width: clamp(50px, 10vw, 60px);
    height: clamp(50px, 10vw, 60px);
    border-radius: 50%;
    background: linear-gradient(45deg, #c300ff, #00e6e6, #ff5733);
    background-size: 300%;
    border: none;
    color: #fff;
    font-size: clamp(1rem, 3vw, 1.2rem);
    font-weight: bold;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    box-shadow: 0 0 20px rgba(195, 0, 255, 0.8), 0 0 30px rgba(0, 230, 230, 0.8);
    animation: pulseButton 3s infinite;
    transition: all 0.3s ease;
}

.circle-btn:hover {
    box-shadow: 0 0 40px #c300ff, 0 0 60px #00e6e6;
    transform: scale(1.1);
}

.win-btn {
    background: linear-gradient(45deg, #33ff66, #c300ff);
    box-shadow: 0 0 15px rgba(51, 255, 102, 0.8);
}

.win-btn:hover {
    box-shadow: 0 0 35px #33ff66, 0 0 55px #c300ff;
}

.game-board {
    display: grid;
    grid-template-columns: repeat(3, 30%);
    gap: 2%;
    margin: 5% auto;
    width: 90%;
}

.cell {
    aspect-ratio: 1;
    background: rgba(255, 255, 255, 0.05);
    border: 2px solid #00e6e6;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: clamp(2rem, 8vw, 3rem);
    color: #fff;
    cursor: pointer;
    text-shadow: 0 0 15px #00e6e6;
    transition: all 0.3s ease;
}

.cell:hover {
    background: rgba(255, 255, 255, 0.15);
    box-shadow: 0 0 25px #c300ff;
}

.cell.x {
    color: #c300ff;
    text-shadow: 0 0 20px #c300ff;
}

.cell.o {
    color: #33ff66;
    text-shadow: 0 0 20px #33ff66;
}

.room-id {
    color: #ff5733;
    text-shadow: 0 0 5px #ff5733;
    margin-bottom: 5%;
    font-size: clamp(1rem, 3.5vw, 1.2rem);
}

.status {
    color: #fff;
    margin-bottom: 5%;
    text-shadow: 0 0 5px #00e6e6;
    font-size: clamp(1rem, 3.5vw, 1.2rem);
}

.waiting-area p {
    color: #c300ff;
    text-shadow: 0 0 15px #c300ff;
    font-size: clamp(1.2rem, 4vw, 1.5rem);
    animation: pulse 1.5s infinite;
}

@keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.5; }
    100% { opacity: 1; }
}

/* Dashboard Layout */
.dashboard {
    position: relative;
    min-height: 80vh;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
}

#profileBtn {
    position: absolute;
    top: 5%;
    right: 5%;
    background: none;
    background-size: cover;
    color: transparent;
    border: 2px solid #c300ff;
}

#walletBtn {
    position: absolute;
    top: 5%;
    left: 5%;
}

.balance-box {
    position: absolute;
    top: 5%;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.95);
    border: 2px solid #ff5733;
    border-radius: 10px;
    padding: 2%;
    width: clamp(100px, 25vw, 150px);
    color: #ff5733;
    font-size: clamp(1rem, 3.5vw, 1.2rem);
    font-weight: bold;
    text-shadow: 0 0 15px #ff5733;
    box-shadow: 0 0 25px rgba(255, 87, 51, 0.8);
    display: flex;
    justify-content: center;
    align-items: center;
}

#playButton {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: clamp(100px, 20vw, 120px);
    border-radius: 50%;
}

#winButton {
    position: absolute;
    bottom: 5%;
    left: 5%;
    width: clamp(50px, 10vw, 60px);
    height: clamp(50px, 10vw, 60px);
    border-radius: 50%;
}

#friendsBtn {
    position: absolute;
    bottom: 5%;
    left: 30%;
}

#tournamentsBtn {
    position: absolute;
    bottom: 5%;
    right: 30%;
}

#tasksBtn {
    position: absolute;
    bottom: 5%;
    right: 5%;
}

.dashboard-center {
    width: 80%;
    margin: 20% auto 10% auto;
}

/* Profile Page */
.profile-page {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 5%;
}

.profile-content {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-top: 3%;
}

.profile-pic-circle {
    width: clamp(80px, 20vw, 100px);
    height: clamp(80px, 20vw, 100px);
    border-radius: 50%;
    border: 2px solid #c300ff;
    margin-bottom: 3%;
    background-size: cover;
    background-position: center;
    box-shadow: 0 0 20px rgba(195, 0, 255, 0.8);
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    color: transparent;
}

.username-container {
    display: flex;
    align-items: center;
    margin-bottom: 5%;
}

.username-display {
    color: #00e6e6;
    font-size: clamp(1rem, 3.5vw, 1.2rem);
    text-shadow: 0 0 10px #00e6e6;
    cursor: pointer;
    padding: 2%;
    border-radius: 5px;
    transition: background 0.3s ease;
}

.username-display:hover {
    background: rgba(195, 0, 255, 0.2);
}

.edit-icon {
    color: #00e6e6;
    margin-left: 2%;
    font-size: clamp(0.8rem, 2.5vw, 1rem);
    text-shadow: 0 0 5px #00e6e6;
    cursor: pointer;
}

.game-history-btn {
    background: linear-gradient(45deg, #ff5733, #c300ff);
    width: 80%;
    padding: 3%;
    border-radius: 5px;
    box-shadow: 0 0 15px rgba(255, 87, 51, 0.8);
}

.game-history-btn:hover {
    box-shadow: 0 0 35px #ff5733, 0 0 55px #c300ff;
}

#backToDashboardFromProfile {
    width: 80%;
    margin-top: 3%;
}

.loader {
    border: 4px solid #00e6e6;
    border-top: 4px solid #c300ff;
    border-radius: 50%;
    width: 30px;
    height: 30px;
    animation: spin 1s linear infinite;
    margin: 10px auto;
    display: none;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

.game-history {
    display: none;
    color: #fff;
    max-height: 300px;
    overflow-y: auto;
    margin-top: 20px;
}

.game-history-item {
    background: rgba(255, 255, 255, 0.1);
    padding: 10px;
    margin: 5px 0;
    border-radius: 5px;
    font-size: clamp(0.8rem, 2.5vw, 0.9rem);
    text-shadow: 0 0 5px #00e6e6;
}

.game-history::-webkit-scrollbar {
    width: 8px;
}

.game-history::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.5);
}

.game-history::-webkit-scrollbar-thumb {
    background: #c300ff;
    border-radius: 4px;
}

@media (max-width: 600px) {
    .container {
        padding: 8%;
        width: 95%;
    }
    h2 {
        font-size: clamp(1.2rem, 4.5vw, 1.5rem);
    }
    button, input {
        padding: 4%;
        font-size: clamp(0.8rem, 2.5vw, 0.9rem);
    }
    .game-board {
        width: 95%;
        grid-template-columns: repeat(3, 31%);
        gap: 1%;
    }
    .cell {
        font-size: clamp(1.5rem, 6vw, 2rem);
    }
    .circle-btn, #playButton, #winButton {
        width: clamp(40px, 8vw, 50px);
        height: clamp(40px, 8vw, 50px);
        font-size: clamp(0.8rem, 2.5vw, 1rem);
    }
    .balance-box {
        width: clamp(80px, 20vw, 120px);
        padding: 3%;
        font-size: clamp(0.8rem, 3vw, 1rem);
    }
    #profileBtn {
        top: 3%;
        right: 3%;
    }
    #walletBtn {
        top: 3%;
        left: 3%;
    }
    .balance-box {
        top: 15%;
    }
    #playButton {
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
    }
    #winButton {
        bottom: 3%;
        left: 3%;
    }
    #friendsBtn {
        bottom: 3%;
        left: 28%;
    }
    #tournamentsBtn {
        bottom: 3%;
        right: 28%;
    }
    #tasksBtn {
        bottom: 3%;
        right: 3%;
    }
    .dashboard-center {
        margin: 25% auto 15% auto;
    }
    .profile-pic-circle {
        width: clamp(60px, 15vw, 80px);
        height: clamp(60px, 15vw, 80px);
    }
    .username-display {
        font-size: clamp(0.8rem, 3vw, 1rem);
    }
    .edit-icon {
        font-size: clamp(0.7rem, 2vw, 0.9rem);
    }
    .profile-content {
        margin-top: 5%;
    }
}
        .loader {
            border: 4px solid #00e6e6;
            border-top: 4px solid #c300ff;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 10px auto;
            display: none;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .game-history {
            display: none;
            color: #fff;
            max-height: 300px;
            overflow-y: auto;
            margin-top: 20px;
        }
        .game-history-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            font-size: clamp(0.8rem, 2.5vw, 0.9rem);
            text-shadow: 0 0 5px #00e6e6;
        }
        /* Scrollbar styling for game history */
        .game-history::-webkit-scrollbar {
            width: 8px;
        }
        .game-history::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.5);
        }
        .game-history::-webkit-scrollbar-thumb {
            background: #c300ff;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <!-- Auth Container (unchanged) -->
    <div class="container" id="authContainer">
        <h2 id="formTitle">Sign Up</h2>
        <div class="input-box">
            <input type="email" id="email" placeholder="Email" required>
        </div>
        <div class="input-box">
            <input type="password" id="password" placeholder="Password" required>
        </div>
        <div class="loader" id="authLoader"></div>
        <button id="authButton">Sign Up</button>
        <span class="toggle-text" id="toggleAuth">Already have an account? Login</span>
    </div>

    <!-- Dashboard (unchanged) -->
    <div class="container dashboard" id="dashboard">
        <div class="balance-box">₹0</div>
        <button class="circle-btn" id="profileBtn">Pro</button>
        <button class="circle-btn" id="walletBtn">W</button>
        <button class="circle-btn" id="friendsBtn">Fr</button>
        <button class="circle-btn" id="tournamentsBtn">To</button>
        <button class="circle-btn" id="tasksBtn">T</button>
        <button class="circle-btn play-btn" id="playButton">Play</button>
        <button class="circle-btn win-btn" id="winButton">Win</button>
        <div class="dashboard-center">
            <h2>Welcome, <span id="userDisplay"></span></h2>
            <div id="verifyEmailPrompt" style="display: none;">
                <p style="color: #ff5733; text-shadow: 0 0 5px #ff5733; margin-bottom: 5%;">
                    Please verify your email to play. Check your inbox!
                </p>
                <button id="resendVerification">Resend Verification Email</button>
            </div>
            <button id="logoutButton">Logout</button>
        </div>
    </div>

    <!-- Profile Page -->
    <div class="container profile-page" id="profilePage">
        <h2>Profile</h2>
        <div class="profile-content">
            <div id="profilePicCircle" class="profile-pic-circle"></div>
            <input type="file" id="profilePicInput" accept="image/png,image/jpeg">
            <div class="username-container">
                <span id="usernameDisplay" class="username-display" contenteditable="false">Set Username</span>
                <span class="edit-icon">✏</span>
            </div>
            <div class="loader" id="profileLoader"></div>
            <div id="userStats">
                <p>Wins: <span id="wins">0</span> | Losses: <span id="losses">0</span> | Ties: <span id="ties">0</span></p>
            </div>
        </div>
        <button class="game-history-btn" id="gameHistoryBtn">Game History</button>
        <div class="game-history" id="gameHistoryList"></div>
        <button id="backToDashboardFromProfile">Back to Dashboard</button>
    </div>

    <!-- Game Page (unchanged) -->
    <div class="container game-page" id="gamePage">
        <h2>Play Tic-Tac-Toe</h2>
        <button id="playRandom">Play with Random Player</button>
        <button id="backToDashboard">Back to Dashboard</button>
    </div>

    <!-- Game Room (unchanged) -->
    <div class="container game-room" id="gameRoom">
        <h2>Tic-Tac-Toe</h2>
        <p class="room-id" id="roomIdDisplay"></p>
        <p class="status" id="gameStatus">Waiting for opponent...</p>
        <p id="playersDisplay"></p>
        <div class="game-board" id="gameBoard">
            <div class="cell" data-index="0"></div>
            <div class="cell" data-index="1"></div>
            <div class="cell" data-index="2"></div>
            <div class="cell" data-index="3"></div>
            <div class="cell" data-index="4"></div>
            <div class="cell" data-index="5"></div>
            <div class="cell" data-index="6"></div>
            <div class="cell" data-index="7"></div>
            <div class="cell" data-index="8"></div>
        </div>
        <button id="leaveRoom">Leave Room</button>
    </div>

    <!-- Waiting Area -->
    <div class="container waiting-area" id="waitingArea">
        <h2>Matchmaking</h2>
        <p>Searching for opponent...</p>
        <div class="loader"></div>
    </div>

    <script type="module">
        // Main script with modular imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-app.js";
        import { 
            getAuth, 
            createUserWithEmailAndPassword, 
            signInWithEmailAndPassword, 
            onAuthStateChanged, 
            signOut, 
            sendEmailVerification 
        } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-auth.js";
        import { 
            getFirestore, 
            doc, 
            setDoc, 
            getDoc, 
            onSnapshot, 
            updateDoc, 
            deleteDoc, 
            collection, 
            addDoc, 
            query, 
            where, 
            getDocs 
        } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-firestore.js";
        import { 
            getStorage, 
            ref, 
            uploadBytes, 
            getDownloadURL 
        } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-storage.js";

        // Firebase Config
        const firebaseConfig = {
            apiKey: "AIzaSyCxUwcTWRApLE7F_LHMXHOrmoQVWabfpgA",
            authDomain: "future-4a5bb.firebaseapp.com",
            projectId: "future-4a5bb",
            storageBucket: "future-4a5bb.firebasestorage.app",
            messagingSenderId: "769026893150",
            appId: "1:769026893150:web:7af5f9679ac495f8d09bcf",
            measurementId: "G-XQ00FD9LZ4"
        };

        // Initialize Firebase
        let auth, db, storage;
        try {
            const app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
            storage = getStorage(app);
            console.log('Firebase initialized successfully');
        } catch (error) {
            console.error('Firebase initialization error:', error);
            showMessage('Failed to initialize Firebase. Check console and verify configuration.', 'error');
        }

        // Utility Functions
        /**
         * Show a temporary message
         * @param {string} message - Message text
         * @param {string} type - 'success' or 'error'
         */
        function showMessage(message, type) {
            const msgDiv = document.createElement('div');
            msgDiv.className = `message ${type}`;
            msgDiv.textContent = message;
            document.body.appendChild(msgDiv);
            msgDiv.style.opacity = '1';
            setTimeout(() => {
                msgDiv.style.opacity = '0';
                setTimeout(() => msgDiv.remove(), 300);
            }, 3000);
        }

        /**
         * Show/hide containers
         * @param {HTMLElement} container - Container to show
         */
        function showContainer(container) {
            const containers = [
                document.getElementById('authContainer'),
                document.getElementById('dashboard'),
                document.getElementById('profilePage'),
                document.getElementById('gamePage'),
                document.getElementById('gameRoom'),
                document.getElementById('waitingArea')
            ];
            containers.forEach(c => c && (c.style.display = 'none'));
            container.style.display = 'block';
        }

        /**
         * Debounce function
         * @param {Function} func - Function to debounce
         * @param {number} wait - Wait time in ms
         * @returns {Function}
         */
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        /**
         * Sanitize username
         * @param {string} username - Username to sanitize
         * @returns {string}
         */
        function sanitizeUsername(username) {
            const maxLength = 20;
            const sanitized = username.replace(/[<>"'&]/g, '').trim();
            return sanitized.slice(0, maxLength);
        }

        // Auth Module
        const authModule = {
            elements: {
                authContainer: document.getElementById('authContainer'),
                formTitle: document.getElementById('formTitle'),
                authButton: document.getElementById('authButton'),
                toggleAuth: document.getElementById('toggleAuth'),
                emailInput: document.getElementById('email'),
                passwordInput: document.getElementById('password'),
                authLoader: document.getElementById('authLoader'),
                logoutButton: document.getElementById('logoutButton'),
                verifyEmailPrompt: document.getElementById('verifyEmailPrompt'),
                resendVerification: document.getElementById('resendVerification')
            },
            isSignUp: true,

            init() {
                this.elements.toggleAuth.addEventListener('click', () => {
                    this.isSignUp = !this.isSignUp;
                    this.elements.formTitle.textContent = this.isSignUp ? 'Sign Up' : 'Login';
                    this.elements.authButton.textContent = this.isSignUp ? 'Sign Up' : 'Login';
                    this.elements.toggleAuth.textContent = this.isSignUp ? 'Already have an account? Login' : 'Need an account? Sign Up';
                });

                this.elements.authButton.addEventListener('click', async () => {
                    const email = this.elements.emailInput.value;
                    const password = this.elements.passwordInput.value;
                    if (!email || !password) {
                        showMessage('Please enter email and password', 'error');
                        return;
                    }
                    this.elements.authLoader.style.display = 'block';
                    try {
                        if (this.isSignUp) {
                            const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                            await sendEmailVerification(userCredential.user);
                            showMessage('Sign Up Successful! Please verify your email.', 'success');
                        } else {
                            await signInWithEmailAndPassword(auth, email, password);
                            showMessage('Login Successful!', 'success');
                        }
                        this.elements.emailInput.value = '';
                        this.elements.passwordInput.value = '';
                    } catch (error) {
                        showMessage(`Error: ${error.message}`, 'error');
                    } finally {
                        this.elements.authLoader.style.display = 'none';
                    }
                });

                this.elements.resendVerification.addEventListener('click', async () => {
                    const user = auth.currentUser;
                    if (user && !user.emailVerified) {
                        try {
                            await sendEmailVerification(user);
                            showMessage('Verification email resent! Check your inbox.', 'success');
                        } catch (error) {
                            showMessage(`Error: ${error.message}`, 'error');
                        }
                    }
                });

                this.elements.logoutButton.addEventListener('click', async () => {
                    try {
                        await signOut(auth);
                        showMessage('Logged out successfully!', 'success');
                        showContainer(this.elements.authContainer);
                        gameModule.cleanup();
                    } catch (error) {
                        showMessage(`Logout failed: ${error.message}`, 'error');
                    }
                });

                onAuthStateChanged(auth, async user => {
                    if (user) {
                        showContainer(document.getElementById('dashboard'));
                        this.elements.verifyEmailPrompt.style.display = user.emailVerified ? 'none' : 'block';
                        document.getElementById('playButton').style.display = user.emailVerified ? 'block' : 'none';
                        try {
                            const userDoc = await getDoc(doc(db, 'users', user.uid));
                            const username = userDoc.exists() && userDoc.data().username ? userDoc.data().username : 'Player';
                            const avatarUrl = userDoc.exists() && userDoc.data().avatarUrl ? userDoc.data().avatarUrl : null;
                            profileModule.updateUI(username, avatarUrl);
                        } catch (error) {
                            showMessage(`Error fetching user data: ${error.message}`, 'error');
                            profileModule.updateUI('Player', null);
                        }
                    } else {
                        showContainer(this.elements.authContainer);
                        profileModule.updateUI('Player', null);
                        gameModule.cleanup();
                    }
                });
            }
        };

        // Profile Module
        const profileModule = {
            elements: {
                userDisplay: document.getElementById('userDisplay'),
                usernameDisplay: document.getElementById('usernameDisplay'),
                profilePicCircle: document.getElementById('profilePicCircle'),
                profilePicInput: document.getElementById('profilePicInput'),
                profileBtn: document.getElementById('profileBtn'),
                gameHistoryBtn: document.getElementById('gameHistoryBtn'),
                gameHistoryList: document.getElementById('gameHistoryList'),
                backToDashboard: document.getElementById('backToDashboardFromProfile'),
                profileLoader: document.getElementById('profileLoader'),
                wins: document.getElementById('wins'),
                losses: document.getElementById('losses'),
                ties: document.getElementById('ties')
            },
            localAvatarUrl: null,
            lastSaveTime: 0,

            updateUI(username, avatarUrl) {
                const firstLetter = username.charAt(0).toUpperCase() || 'P';
                if (avatarUrl && avatarUrl !== 'local') {
                    this.elements.profileBtn.style.backgroundImage = `url(${avatarUrl})`;
                    this.elements.profilePicCircle.style.backgroundImage = `url(${avatarUrl})`;
                    this.elements.profileBtn.style.color = 'transparent';
                    this.elements.profilePicCircle.style.color = 'transparent';
                } else if (avatarUrl === 'local' && this.localAvatarUrl) {
                    this.elements.profileBtn.style.backgroundImage = `url(${this.localAvatarUrl})`;
                    this.elements.profilePicCircle.style.backgroundImage = `url(${this.localAvatarUrl})`;
                    this.elements.profileBtn.style.color = 'transparent';
                    this.elements.profilePicCircle.style.color = 'transparent';
                } else {
                    const canvas = document.createElement('canvas');
                    const size = 100;
                    canvas.width = size;
                    canvas.height = size;
                    const ctx = canvas.getContext('2d');
                    ctx.beginPath();
                    ctx.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2);
                    ctx.fillStyle = '#c300ff';
                    ctx.fill();
                    ctx.font = 'bold 60px Arial';
                    ctx.fillStyle = '#fff';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(firstLetter, size / 2, size / 2);
                    const canvasUrl = canvas.toDataURL();
                    this.elements.profileBtn.style.backgroundImage = `url(${canvasUrl})`;
                    this.elements.profilePicCircle.style.backgroundImage = `url(${canvasUrl})`;
                    this.elements.profileBtn.style.color = 'transparent';
                    this.elements.profilePicCircle.style.color = 'transparent';
                }
                this.elements.profileBtn.style.backgroundSize = 'cover';
                this.elements.profileBtn.style.border = '2px solid #c300ff';
                this.elements.profilePicCircle.style.backgroundSize = 'cover';
                this.elements.profilePicCircle.style.border = '2px solid #c300ff';
                this.elements.userDisplay.textContent = username;
                this.elements.usernameDisplay.textContent = username;
            },

            async saveProfile(username, avatarFile) {
                const now = Date.now();
                if (now - this.lastSaveTime < 1000) return;
                this.lastSaveTime = now;
                const user = auth.currentUser;
                if (!user) {
                    showMessage('Please log in first', 'error');
                    return;
                }
                if (!user.emailVerified) {
                    showMessage('Please verify your email first', 'error');
                    return;
                }
                this.elements.profileLoader.style.display = 'block';
                try {
                    const userDocRef = doc(db, 'users', user.uid);
                    let userData = { 
                        username: sanitizeUsername(username),
                        avatarUrl: null 
                    };

                    if (avatarFile) {
                        const validTypes = ['image/png', 'image/jpeg'];
                        const maxSize = 2 * 1024 * 1024; // 2MB
                        if (!validTypes.includes(avatarFile.type)) {
                            showMessage('Please upload a PNG or JPEG image', 'error');
                            return;
                        }
                        if (avatarFile.size > maxSize) {
                            showMessage('Image must be under 2MB', 'error');
                            return;
                        }
                        const storageRef = ref(storage, `users/${user.uid}/avatar`);
                        const uploadResult = await uploadBytes(storageRef, avatarFile);
                        const avatarUrl = await getDownloadURL(storageRef);
                        userData.avatarUrl = avatarUrl;
                        this.localAvatarUrl = null;
                    }

                    await setDoc(userDocRef, {
                        ...userData,
                        stats: { wins: 0, losses: 0, ties: 0 }
                    }, { merge: true });
                    this.updateUI(userData.username, userData.avatarUrl);
                    showMessage('Profile updated!', 'success');

                    // Update stats display
                    const userDoc = await getDoc(userDocRef);
                    const stats = userDoc.data()?.stats || { wins: 0, losses: 0, ties: 0 };
                    this.elements.wins.textContent = stats.wins;
                    this.elements.losses.textContent = stats.losses;
                    this.elements.ties.textContent = stats.ties;
                } catch (error) {
                    showMessage(`Error saving profile: ${error.message}`, 'error');
                } finally {
                    this.elements.profileLoader.style.display = 'none';
                }
            },

            async showGameHistory() {
                const user = auth.currentUser;
                if (!user) {
                    showMessage('Please log in first', 'error');
                    return;
                }
                this.elements.gameHistoryList.innerHTML = '';
                try {
                    const q = query(collection(db, 'gameHistory'), where('userId', '==', user.uid));
                    const snapshot = await getDocs(q);
                    if (snapshot.empty) {
                        this.elements.gameHistoryList.innerHTML = '<p>No games played yet.</p>';
                    } else {
                        snapshot.forEach(doc => {
                            const data = doc.data();
                            const item = document.createElement('div');
                            item.className = 'game-history-item';
                            item.textContent = `${data.result} vs ${data.opponentUsername} on ${new Date(data.timestamp).toLocaleString()}`;
                            this.elements.gameHistoryList.appendChild(item);
                        });
                    }
                    this.elements.gameHistoryList.style.display = 'block';
                } catch (error) {
                    showMessage(`Error loading game history: ${error.message}`, 'error');
                }
            },

            init() {
                this.elements.profilePicCircle.addEventListener('click', () => {
                    this.elements.profilePicInput.click();
                });

                this.elements.profilePicInput.addEventListener('change', async e => {
                    const file = e.target.files[0];
                    if (file) {
                        await this.saveProfile(this.elements.usernameDisplay.textContent, file);
                        this.elements.profilePicInput.value = '';
                    }
                });

                this.elements.usernameDisplay.addEventListener('click', () => {
                    this.elements.usernameDisplay.contentEditable = 'true';
                    this.elements.usernameDisplay.focus();
                });

                this.elements.usernameDisplay.addEventListener('blur', async () => {
                    this.elements.usernameDisplay.contentEditable = 'false';
                    const newUsername = sanitizeUsername(this.elements.usernameDisplay.textContent);
                    if (!newUsername) {
                        showMessage('Please enter a valid username', 'error');
                        const userDoc = await getDoc(doc(db, 'users', auth.currentUser?.uid));
                        this.elements.usernameDisplay.textContent = userDoc.exists() && userDoc.data().username ? userDoc.data().username : 'Player';
                        return;
                    }
                    await this.saveProfile(newUsername, null);
                });

                this.elements.usernameDisplay.addEventListener('keydown', e => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        this.elements.usernameDisplay.blur();
                    }
                });

                this.elements.profileBtn.addEventListener('click', async () => {
                    const user = auth.currentUser;
                    if (!user) {
                        showMessage('Please log in first', 'error');
                        showContainer(document.getElementById('authContainer'));
                        return;
                    }
                    try {
                        const userDoc = await getDoc(doc(db, 'users', user.uid));
                        const username = userDoc.exists() && userDoc.data().username ? userDoc.data().username : 'Player';
                        const avatarUrl = userDoc.exists() && userDoc.data().avatarUrl ? userDoc.data().avatarUrl : null;
                        const stats = userDoc.exists() && userDoc.data().stats ? userDoc.data().stats : { wins: 0, losses: 0, ties: 0 };
                        this.updateUI(username, avatarUrl);
                        this.elements.wins.textContent = stats.wins;
                        this.elements.losses.textContent = stats.losses;
                        this.elements.ties.textContent = stats.ties;
                        showContainer(document.getElementById('profilePage'));
                    } catch (error) {
                        showMessage(`Error loading profile: ${error.message}`, 'error');
                    }
                });

                this.elements.gameHistoryBtn.addEventListener('click', () => {
                    this.showGameHistory();
                });

                this.elements.backToDashboard.addEventListener('click', () => {
                    showContainer(document.getElementById('dashboard'));
                    this.elements.gameHistoryList.style.display = 'none';
                });
            }
        };

        // Game Module
        const gameModule = {
            elements: {
                playButton: document.getElementById('playButton'),
                playRandom: document.getElementById('playRandom'),
                backToDashboard: document.getElementById('backToDashboard'),
                gameRoom: document.getElementById('gameRoom'),
                roomIdDisplay: document.getElementById('roomIdDisplay'),
                gameStatus: document.getElementById('gameStatus'),
                gameBoard: document.getElementById('gameBoard'),
                leaveRoom: document.getElementById('leaveRoom'),
                playersDisplay: document.getElementById('playersDisplay')
            },
            currentRoomId: null,
            currentPlayer: null,
            opponentUsername: null,
            unsubscribeRoom: null,

            checkWinner(board) {
                const winPatterns = [
                    [0, 1, 2], [3, 4, 5], [6, 7, 8],
                    [0, 3, 6], [1, 4, 7], [2, 5, 8],
                    [0, 4, 8], [2, 4, 6]
                ];
                for (const pattern of winPatterns) {
                    const [a, b, c] = pattern;
                    if (board[a] && board[a] === board[b] && board[b] === board[c]) {
                        return board[a];
                    }
                }
                if (board.every(cell => cell !== '')) {
                    return 'tie';
                }
                return null;
            },

            renderBoard(board) {
                const cells = this.elements.gameBoard.querySelectorAll('.cell');
                cells.forEach((cell, index) => {
                    cell.textContent = board[index];
                    cell.className = 'cell';
                    if (board[index] === 'X') cell.classList.add('x');
                    if (board[index] === 'O') cell.classList.add('o');
                });
            },

            async handleGameEnd(result, username) {
                const user = auth.currentUser;
                if (!user || !this.currentRoomId) return;
                try {
                    const userDocRef = doc(db, 'users', user.uid);
                    const userDoc = await getDoc(userDocRef);
                    let stats = userDoc.data()?.stats || { wins: 0, losses: 0, ties: 0 };
                    let resultText = '';
                    if (result === this.currentPlayer) {
                        resultText = 'Win';
                        showMessage('You won!', 'success');
                        stats.wins += 1;
                    } else if (result === 'tie') {
                        resultText = 'Tie';
                        showMessage('Game tied!', 'success');
                        stats.ties += 1;
                    } else {
                        resultText = 'Loss';
                        showMessage(`${this.opponentUsername} won!`, 'error');
                        stats.losses += 1;
                    }
                    await updateDoc(userDocRef, { stats });
                    await updateDoc(doc(db, 'rooms', this.currentRoomId), { status: 'finished', winner: result });

                    // Save game history
                    await addDoc(collection(db, 'gameHistory'), {
                        userId: user.uid,
                        opponentUsername: this.opponentUsername,
                        result: resultText,
                        timestamp: Date.now()
                    });

                    setTimeout(() => {
                        this.cleanup();
                        showContainer(document.getElementById('dashboard'));
                    }, 2000);
                } catch (error) {
                    showMessage(`Error updating stats: ${error.message}`, 'error');
                }
            },

            listenToRoom(roomId, username) {
                if (this.unsubscribeRoom) this.unsubscribeRoom();
                this.unsubscribeRoom = onSnapshot(doc(db, 'rooms', roomId), async snapshot => {
                    if (!snapshot.exists()) {
                        showMessage('Room closed', 'error');
                        this.cleanup();
                        return;
                    }
                    const data = snapshot.data();
                    if (data.status === 'active' && data.player1 && data.player2) {
                        let winner = data.winner || this.checkWinner(data.board);
                        if (winner && !data.winner) {
                            await updateDoc(doc(db, 'rooms', roomId), { winner, status: 'finished' });
                        }
                        this.elements.gameStatus.textContent = data.turn === this.currentPlayer ? 'Your turn' : `Opponent's turn (${data.turn})`;
                        this.elements.playersDisplay.textContent = `${data.player1Username} (X) vs ${data.player2Username} (O)`;
                        this.opponentUsername = this.currentPlayer === 'X' ? data.player2Username : data.player1Username;
                        this.renderBoard(data.board);
                        if (winner) {
                            await this.handleGameEnd(winner, username);
                        }
                    }
                }, error => {
                    showMessage(`Room error: ${error.message}`, 'error');
                });
            },

            cleanup() {
                if (this.currentRoomId) {
                    updateDoc(doc(db, 'rooms', this.currentRoomId), { status: 'closed' }).catch(error => {
                        console.error('Cleanup error:', error);
                    });
                    this.currentRoomId = null;
                }
                if (this.unsubscribeRoom) {
                    this.unsubscribeRoom();
                    this.unsubscribeRoom = null;
                }
                this.currentPlayer = null;
                this.opponentUsername = null;
                this.elements.gameBoard.querySelectorAll('.cell').forEach(cell => {
                    cell.textContent = '';
                    cell.className = 'cell';
                });
                this.elements.gameStatus.textContent = 'Waiting for opponent...';
                this.elements.roomIdDisplay.textContent = '';
                this.elements.playersDisplay.textContent = '';
                showContainer(document.getElementById('dashboard'));
            },

            init() {
                this.elements.playButton.addEventListener('click', async () => {
                    const user = auth.currentUser;
                    if (!user) {
                        showMessage('Please log in first', 'error');
                        showContainer(document.getElementById('authContainer'));
                        return;
                    }
                    if (!user.emailVerified) {
                        showMessage('Please verify your email first', 'error');
                        return;
                    }
                    try {
                        const userDoc = await getDoc(doc(db, 'users', user.uid));
                        if (userDoc.exists() && userDoc.data().username) {
                            showContainer(document.getElementById('gamePage'));
                        } else {
                            showMessage('Please set a username first', 'error');
                            showContainer(document.getElementById('profilePage'));
                        }
                    } catch (error) {
                        showMessage(`Error: ${error.message}`, 'error');
                    }
                });

                this.elements.backToDashboard.addEventListener('click', () => {
                    showContainer(document.getElementById('dashboard'));
                });

                this.elements.playRandom.addEventListener('click', async () => {
                    const user = auth.currentUser;
                    if (!user || !user.emailVerified) {
                        showMessage('Please verify your email first', 'error');
                        showContainer(document.getElementById('authContainer'));
                        return;
                    }
                    let matchmakingId = null;
                    try {
                        const userDoc = await getDoc(doc(db, 'users', user.uid));
                        const username = userDoc.data()?.username || 'Player';
                        showContainer(document.getElementById('waitingArea'));

                        // Clean up existing matchmaking entries
                        const userEntries = await getDocs(query(collection(db, 'matchmaking'), where('userId', '==', user.uid)));
                        for (const entry of userEntries.docs) {
                            await deleteDoc(doc(db, 'matchmaking', entry.id));
                        }

                        // Add to matchmaking pool
                        const matchmakingData = {
                            userId: user.uid,
                            username,
                            status: 'waiting',
                            timestamp: Date.now()
                        };
                        const matchmakingRef = await addDoc(collection(db, 'matchmaking'), matchmakingData);
                        matchmakingId = matchmakingRef.id;

                        // Listen for matchmaking entry
                        let isPaired = false;
                        const unsubscribeMatch = onSnapshot(doc(db, 'matchmaking', matchmakingId), async snapshot => {
                            if (!snapshot.exists()) {
                                if (!isPaired) {
                                    showContainer(document.getElementById('gamePage'));
                                    showMessage('Matchmaking canceled.', 'error');
                                }
                                return;
                            }
                            const data = snapshot.data();
                            if (data.status === 'paired' && data.roomId) {
                                isPaired = true;
                                this.currentRoomId = data.roomId;
                                this.currentPlayer = data.playerSymbol || 'O';
                                this.opponentUsername = data.opponentUsername;
                                await deleteDoc(doc(db, 'matchmaking', matchmakingId));
                                unsubscribeMatch();
                                showContainer(this.elements.gameRoom);
                                this.elements.roomIdDisplay.textContent = `Room ID: ${this.currentRoomId}`;
                                this.listenToRoom(this.currentRoomId, username);
                                showMessage('Opponent found! Game started.', 'success');
                            }
                        }, error => {
                            showMessage('Matchmaking failed. Please try again.', 'error');
                            if (matchmakingId) {
                                deleteDoc(doc(db, 'matchmaking', matchmakingId)).catch(err => console.error('Cleanup error:', err));
                            }
                            unsubscribeMatch();
                            showContainer(document.getElementById('gamePage'));
                        });

                        // Check for unpaired players
                        const now = Date.now();
                        const q = query(collection(db, 'matchmaking'), where('status', '==', 'waiting'));
                        const existingEntries = await getDocs(q);
                        const opponentDocs = existingEntries.docs.filter(doc => {
                            const data = doc.data();
                            return data.userId !== user.uid && (now - data.timestamp) < 20000;
                        });

                        if (opponentDocs.length > 0 && !isPaired) {
                            const opponentDoc = opponentDocs[0];
                            const opponent = opponentDoc.data();
                            isPaired = true;
                            const roomData = {
                                player1: user.uid,
                                player1Username: username,
                                player2: opponent.userId,
                                player2Username: opponent.username,
                                board: ['', '', '', '', '', '', '', '', ''],
                                turn: 'X',
                                status: 'active',
                                createdAt: Date.now()
                            };
                            const roomRef = await addDoc(collection(db, 'rooms'), roomData);
                            this.currentRoomId = roomRef.id;
                            this.currentPlayer = 'X';
                            this.opponentUsername = opponent.username;

                            await updateDoc(doc(db, 'matchmaking', opponentDoc.id), {
                                status: 'paired',
                                roomId: roomRef.id,
                                playerSymbol: 'O',
                                opponentUsername: username
                            });

                            await deleteDoc(doc(db, 'matchmaking', matchmakingId));
                            unsubscribeMatch();
                            showContainer(this.elements.gameRoom);
                            this.elements.roomIdDisplay.textContent = `Room ID: ${roomRef.id}`;
                            this.listenToRoom(roomRef.id, username);
                            showMessage('Opponent found! Game started.', 'success');
                        } else {
                            for (const doc of existingEntries.docs) {
                                if ((now - doc.data().timestamp) >= 20000) {
                                    await deleteDoc(doc(db, 'matchmaking', doc.id));
                                }
                            }
                            setTimeout(() => {
                                if (!isPaired) {
                                    unsubscribeMatch();
                                    if (matchmakingId) {
                                        deleteDoc(doc(db, 'matchmaking', matchmakingId)).catch(err => console.error('Cleanup error:', err));
                                    }
                                    showContainer(document.getElementById('gamePage'));
                                    showMessage('No opponent found. Try again later.', 'error');
                                }
                            }, 20000);
                        }
                    } catch (error) {
                        showMessage('Matchmaking failed. Please try again.', 'error');
                        if (matchmakingId) {
                            deleteDoc(doc(db, 'matchmaking', matchmakingId)).catch(err => console.error('Cleanup error:', err));
                        }
                        showContainer(document.getElementById('gamePage'));
                    }
                });

                this.elements.gameBoard.addEventListener('click', async e => {
                    const cell = e.target;
                    if (!cell.classList.contains('cell') || !this.currentRoomId) return;
                    const index = cell.dataset.index;
                    try {
                        const roomDoc = await getDoc(doc(db, 'rooms', this.currentRoomId));
                        const data = roomDoc.data();
                        if (!data) {
                            showMessage('Room not found', 'error');
                            return;
                        }
                        if (data.board[index] !== '' || data.winner || data.status !== 'active') return;
                        if ((this.currentPlayer === 'X' && data.turn !== 'X') || (this.currentPlayer === 'O' && data.turn !== 'O')) {
                            showMessage('Not your turn!', 'error');
                            return;
                        }
                        const newBoard = [...data.board];
                        newBoard[index] = this.currentPlayer;
                        const newTurn = this.currentPlayer === 'X' ? 'O' : 'X';
                        await updateDoc(doc(db, 'rooms', this.currentRoomId), {
                            board: newBoard,
                            turn: newTurn
                        });
                    } catch (error) {
                        showMessage(`Error: ${error.message}`, 'error');
                    }
                });

                this.elements.leaveRoom.addEventListener('click', () => {
                    showMessage('Left room', 'success');
                    this.cleanup();
                });
            }
        };

        // Initialize Modules
        authModule.init();
        profileModule.init();
        gameModule.init();
    </script>
</body>
</html>
