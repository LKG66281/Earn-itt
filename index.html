<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Tic-Tac-Toe</title>
    <!-- CSS will be added in Part 2 -->
    <style>
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: 'Arial', sans-serif;
    }

    body {
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        background: linear-gradient(45deg, #0a001a, #001933, #1a000a);
        background-size: 400%;
        animation: bgGlow 15s ease infinite;
        overflow-x: hidden;
    }

    @keyframes bgGlow {
        0% { background-position: 0% 50%; }
        50% { background-position: 400% 50%; }
        100% { background-position: 0% 50%; }
    }

    .container {
        background: rgba(0, 0, 0, 0.9);
        padding: 5%;
        border-radius: 10px;
        box-shadow: 0 0 30px rgba(195, 0, 255, 0.8), 0 0 50px rgba(0, 230, 230, 0.8);
        width: min(90%, 500px);
        text-align: center;
        position: relative;
        z-index: 1;
    }

    h2 {
        color: #c300ff;
        text-shadow: 0 0 15px #c300ff, 0 0 25px #00e6e6;
        margin-bottom: 5%;
        font-size: clamp(1.5rem, 5vw, 2rem);
    }

    .input-box {
        margin-bottom: 5%;
        width: 80%;
        margin-left: auto;
        margin-right: auto;
    }

    input[type="text"], input[type="file"], input[type="email"], input[type="password"] {
        width: 100%;
        padding: 3%;
        background: rgba(255, 255, 255, 0.1);
        border: none;
        outline: none;
        border-radius: 25px;
        color: #fff;
        font-size: clamp(0.9rem, 3vw, 1rem);
        box-shadow: 0 0 10px rgba(0, 230, 230, 0.6);
        transition: box-shadow 0.3s ease;
    }

    input[type="file"] {
        display: none;
    }

    input:focus {
        box-shadow: 0 0 25px #c300ff, 0 0 35px #00e6e6;
    }

    button {
        width: 100%;
        padding: 3%;
        background: linear-gradient(45deg, #c300ff, #00e6e6);
        background-size: 200%;
        border: none;
        border-radius: 5px;
        color: #000;
        font-size: clamp(0.9rem, 3vw, 1rem);
        cursor: pointer;
        text-shadow: 0 0 5px #fff;
        box-shadow: 0 0 15px rgba(195, 0, 255, 0.8);
        transition: all 0.3s ease;
        margin-bottom: 3%;
        animation: pulseButton 2s infinite;
    }

    @keyframes pulseButton {
        0% { background-position: 0% 50%; }
        50% { background-position: 200% 50%; }
        100% { background-position: 0% 50%; }
    }

    button:hover {
        box-shadow: 0 0 35px #c300ff, 0 0 55px #00e6e6;
        color: #fff;
    }

    .toggle-text {
        color: #00e6e6;
        cursor: pointer;
        margin-top: 3%;
        display: inline-block;
        text-shadow: 0 0 5px #00e6e6;
        font-size: clamp(0.8rem, 2.5vw, 0.9rem);
    }

    .toggle-text:hover {
        text-decoration: underline;
        text-shadow: 0 0 15px #c300ff;
    }

    .message {
        position: fixed;
        top: 5%;
        right: 5%;
        padding: 3%;
        border-radius: 5px;
        color: #fff;
        font-size: clamp(0.8rem, 2.5vw, 0.9rem);
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        opacity: 0;
        transition: opacity 0.3s ease;
        z-index: 1000;
    }

    .message.success {
        background: #33ff66;
        text-shadow: 0 0 5px #33ff66;
    }

    .message.error {
        background: #ff5733;
        text-shadow: 0 0 5px #ff5733;
    }

    .dashboard, .game-page, .game-room, .waiting-area, .profile-page, .game-history-page, .friends-page {
        display: none;
        color: #fff;
    }

    .play-btn {
        background: linear-gradient(45deg, #ff5733, #c300ff);
        box-shadow: 0 0 15px rgba(255, 87, 51, 0.8);
    }

    .play-btn:hover {
        box-shadow: 0 0 35px #ff5733, 0 0 55px #c300ff;
    }

    .circle-btn {
        width: clamp(50px, 10vw, 60px);
        height: clamp(50px, 10vw, 60px);
        border-radius: 50%;
        background: linear-gradient(45deg, #c300ff, #00e6e6, #ff5733);
        background-size: 300%;
        border: none;
        color: #fff;
        font-size: clamp(1rem, 3vw, 1.2rem);
        font-weight: bold;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        box-shadow: 0 0 20px rgba(195, 0, 255, 0.8), 0 0 30px rgba(0, 230, 230, 0.8);
        animation: pulseButton 3s infinite;
        transition: all 0.3s ease;
    }

    .circle-btn:hover {
        box-shadow: 0 0 40px #c300ff, 0 0 60px #00e6e6;
        transform: scale(1.1);
    }

    .win-btn {
        background: linear-gradient(45deg, #33ff66, #c300ff);
        box-shadow: 0 0 15px rgba(51, 255, 102, 0.8);
    }

    .win-btn:hover {
        box-shadow: 0 0 35px #33ff66, 0 0 55px #c300ff;
    }

    .friends-btn {
        background: linear-gradient(45deg, #00e6e6, #ff5733);
        box-shadow: 0 0 15px rgba(0, 230, 230, 0.8);
    }

    .friends-btn:hover {
        box-shadow: 0 0 35px #00e6e6, 0 0 55px #ff5733;
    }

    .game-board {
        display: grid;
        grid-template-columns: repeat(3, 30%);
        gap: 2%;
        margin: 5% auto;
        width: 90%;
    }

    .cell {
        aspect-ratio: 1;
        background: rgba(255, 255, 255, 0.05);
        border: 2px solid #00e6e6;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: clamp(2rem, 8vw, 3rem);
        color: #fff;
        cursor: pointer;
        text-shadow: 0 0 15px #00e6e6;
        transition: all 0.3s ease;
    }

    .cell:hover {
        background: rgba(255, 255, 255, 0.15);
        box-shadow: 0 0 25px #c300ff;
    }

    .cell.x {
        color: #c300ff;
        text-shadow: 0 0 20px #c300ff;
    }

    .cell.o {
        color: #33ff66;
        text-shadow: 0 0 20px #33ff66;
    }

    .room-id {
        color: #ff5733;
        text-shadow: 0 0 5px #ff5733;
        margin-bottom: 5%;
        font-size: clamp(1rem, 3.5vw, 1.2rem);
    }

    .status {
        color: #fff;
        margin-bottom: 5%;
        text-shadow: 0 0 5px #00e6e6;
        font-size: clamp(1rem, 3.5vw, 1.2rem);
    }

    .waiting-area p {
        color: #c300ff;
        text-shadow: 0 0 15px #c300ff;
        font-size: clamp(1.2rem, 4vw, 1.5rem);
        animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
        0% { opacity: 1; }
        50% { opacity: 0.5; }
        100% { opacity: 1; }
    }

    /* Dashboard Layout */
    .dashboard {
        position: relative;
        min-height: 80vh;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
    }

    #profileBtn {
        position: absolute;
        top: 5%;
        right: 5%;
        background: none;
        background-size: cover;
        color: transparent;
        border: 2px solid #c300ff;
    }

    #walletBtn {
        position: absolute;
        top: 5%;
        left: 5%;
    }

    .balance-box {
        position: absolute;
        top: 5%;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.95);
        border: 2px solid #ff5733;
        border-radius: 10px;
        padding: 2%;
        width: clamp(100px, 25vw, 150px);
        color: #ff5733;
        font-size: clamp(1rem, 3.5vw, 1.2rem);
        font-weight: bold;
        text-shadow: 0 0 15px #ff5733;
        box-shadow: 0 0 25px rgba(255, 87, 51, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
    }

    #playButton {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: clamp(100px, 20vw, 120px);
        border-radius: 50%;
    }

    #winButton {
        position: absolute;
        bottom: 5%;
        left: 5%;
        width: clamp(50px, 10vw, 60px);
        height: clamp(50px, 10vw, 60px);
        border-radius: 50%;
    }

    #friendsBtn {
        position: absolute;
        bottom: 5%;
        left: 30%;
    }

    #tournamentsBtn {
        position: absolute;
        bottom: 5%;
        right: 30%;
    }

    #tasksBtn {
        position: absolute;
        bottom: 5%;
        right: 5%;
    }

    .dashboard-center {
        width: 80%;
        margin: 20% auto 10% auto;
    }

    /* Profile Page */
    .profile-page {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 5%;
    }

    .profile-content {
        display: flex;
        flex-direction: column;
        align-items: center;
        margin-top: 3%;
    }

    .profile-pic-circle {
        width: clamp(80px, 20vw, 100px);
        height: clamp(80px, 20vw, 100px);
        border-radius: 50%;
        border: 2px solid #c300ff;
        margin-bottom: 3%;
        background-size: cover;
        background-position: center;
        box-shadow: 0 0 20px rgba(195, 0, 255, 0.8);
        cursor: pointer;
        display: flex;
        justify-content: center;
        align-items: center;
        color: transparent;
    }

    .username-container {
        display: flex;
        align-items: center;
        margin-bottom: 5%;
    }

    .username-display {
        color: #00e6e6;
        font-size: clamp(1rem, 3.5vw, 1.2rem);
        text-shadow: 0 0 10px #00e6e6;
        cursor: pointer;
        padding: 2%;
        border-radius: 5px;
        transition: background 0.3s ease;
    }

    .username-display:hover {
        background: rgba(195, 0, 255, 0.2);
    }

    .edit-icon {
        color: #00e6e6;
        margin-left: 2%;
        font-size: clamp(0.8rem, 2.5vw, 1rem);
        text-shadow: 0 0 5px #00e6e6;
        cursor: pointer;
    }

    .game-history-btn {
        background: linear-gradient(45deg, #ff5733, #c300ff);
        width: 80%;
        padding: 3%;
        border-radius: 5px;
        box-shadow: 0 0 15px rgba(255, 87, 51, 0.8);
    }

    .game-history-btn:hover {
        box-shadow: 0 0 35px #ff5733, 0 0 55px #c300ff;
    }

    #backToDashboardFromProfile {
        width: 80%;
        margin-top: 3%;
    }

    /* Game History Page */
    .game-history-page {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 5%;
    }

    .history-container {
        width: 100%;
        display: flex;
        flex-direction: column;
        gap: 15px;
        margin-bottom: 5%;
    }

    .history-box {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 15px;
        padding: 4%;
        text-align: center;
        transition: transform 0.3s ease;
    }

    .history-box.win {
        border: 2px solid #33ff66;
        box-shadow: 0 0 15px #33ff66, 0 0 25px #33ff66;
    }

    .history-box.loss-tie {
        border: 2px solid #ff5733;
        box-shadow: 0 0 15px #ff5733, 0 0 25px #ff5733;
    }

    .history-box:hover {
        transform: scale(1.05);
    }

    .history-box p {
        color: #fff;
        font-size: clamp(0.9rem, 2.5vw, 1rem);
        text-shadow: 0 0 5px #00e6e6;
        margin-bottom: 2%;
    }

    .stats-summary {
        margin-bottom: 5%;
        color: #33ff66;
        font-size: clamp(1rem, 3.5vw, 1.2rem);
        text-shadow: 0 0 10px #33ff66;
    }

    #backToProfile {
        width: 80%;
        background: linear-gradient(45deg, #c300ff, #ff5733);
    }

    #backToProfile:hover {
        box-shadow: 0 0 35px #c300ff, 0 0 55px #ff5733;
    }

    /* Friends Page */
    .friends-page {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 5%;
    }

    .tabs {
        display: flex;
        width: 100%;
        margin-bottom: 5%;
        gap: 2%;
    }

    .tab-btn {
        flex: 1;
        background: linear-gradient(45deg, #c300ff, #ff5733);
        border-radius: 5px;
        padding: 3%;
        font-size: clamp(0.9rem, 2.5vw, 1rem);
        cursor: pointer;
        box-shadow: 0 0 10px rgba(195, 0, 255, 0.8);
        transition: all 0.3s ease;
    }

    .tab-btn.active {
        background: linear-gradient(45deg, #00e6e6, #33ff66);
        box-shadow: 0 0 20px rgba(0, 230, 230, 0.8);
    }

    .tab-btn:hover {
        box-shadow: 0 0 25px #c300ff;
    }

    .tab-content {
        width: 100%;
        display: none;
    }

    .tab-content.active {
        display: block;
    }

    .friends-list, #searchResults, #friendRequests {
        display: flex;
        flex-direction: column;
        gap: 15px;
    }

    .friend-box, .result-box, .request-box {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 15px;
        padding: 4%;
        border: 2px solid #33ff66;
        box-shadow: 0 0 15px #33ff66;
        transition: transform 0.3s ease;
    }

    .friend-box:hover, .result-box:hover, .request-box:hover {
        transform: scale(1.05);
    }

    .friend-box p, .result-box p, .request-box p {
        color: #fff;
        font-size: clamp(0.9rem, 2.5vw, 1rem);
        text-shadow: 0 0 5px #00e6e6;
        margin-bottom: 2%;
    }

    .action-btn {
        width: 80%;
        margin: 2% auto;
        background: linear-gradient(45deg, #ff5733, #c300ff);
        box-shadow: 0 0 10px rgba(255, 87, 51, 0.8);
    }

    .action-btn:hover {
        box-shadow: 0 0 25px #ff5733;
    }

    #searchFriend, #backToDashboardFromFriends {
        width: 80%;
        margin: 3% auto;
    }

    @media (max-width: 600px) {
        .container {
            padding: 8%;
            width: 95%;
        }
        h2 {
            font-size: clamp(1.2rem, 4.5vw, 1.5rem);
        }
        button, input {
            padding: 4%;
            font-size: clamp(0.8rem, 2.5vw, 0.9rem);
        }
        .game-board {
            width: 95%;
            grid-template-columns: repeat(3, 31%);
            gap: 1%;
        }
        .cell {
            font-size: clamp(1.5rem, 6vw, 2rem);
        }
        .circle-btn, #playButton, #winButton, #friendsBtn {
            width: clamp(40px, 8vw, 50px);
            height: clamp(40px, 8vw, 50px);
            font-size: clamp(0.8rem, 2.5vw, 1rem);
        }
        .balance-box {
            width: clamp(80px, 20vw, 120px);
            padding: 3%;
            font-size: clamp(0.8rem, 3vw, 1rem);
        }
        #profileBtn {
            top: 3%;
            right: 3%;
        }
        #walletBtn {
            top: 3%;
            left: 3%;
        }
        .balance-box {
            top: 15%;
        }
        #playButton {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        #winButton {
            bottom: 3%;
            left: 3%;
        }
        #friendsBtn {
            bottom: 3%;
            left: 28%;
        }
        #tournamentsBtn {
            bottom: 3%;
            right: 28%;
        }
        #tasksBtn {
            bottom: 3%;
            right: 3%;
        }
        .dashboard-center {
            margin: 25% auto 15% auto;
        }
        .profile-pic-circle {
            width: clamp(60px, 15vw, 80px);
            height: clamp(60px, 15vw, 80px);
        }
        .username-display {
            font-size: clamp(0.8rem, 3vw, 1rem);
        }
        .edit-icon {
            font-size: clamp(0.7rem, 2vw, 0.9rem);
        }
        .profile-content {
            margin-top: 5%;
        }
        .history-box p, .friend-box p, .result-box p, .request-box p {
            font-size: clamp(0.8rem, 2vw, 0.9rem);
            margin-bottom: 3%;
        }
        .history-container, .friends-list, #searchResults, #friendRequests {
            gap: 10px;
        }
        .stats-summary {
            font-size: clamp(0.8rem, 3vw, 1rem);
        }
        .tabs {
            flex-direction: column;
            gap: 5px;
        }
        .tab-btn {
            width: 100%;
            padding: 4%;
        }
    }
</style>
</head>
<body>
    <!-- Auth Container -->
    <div class="container" id="authContainer">
        <h2 id="formTitle">Sign Up</h2>
        <div class="input-box">
            <input type="email" id="email" placeholder="Email" required>
        </div>
        <div class="input-box">
            <input type="password" id="password" placeholder="Password" required>
        </div>
        <div class="input-box">
            <input type="text" id="username" placeholder="Username" required>
        </div>
        <button id="authButton">Sign Up</button>
        <span class="toggle-text" id="toggleAuth">Already have an account? Login</span>
    </div>

    <!-- Dashboard -->
    <div class="container dashboard" id="dashboard">
        <div class="balance-box">₹0</div>
        <button class="circle-btn" id="profileBtn">Pro</button>
        <button class="circle-btn" id="walletBtn">W</button>
        <button class="circle-btn friends-btn" id="friendsBtn">Fr</button>
        <button class="circle-btn" id="tournamentsBtn">To</button>
        <button class="circle-btn" id="tasksBtn">T</button>
        <button class="circle-btn play-btn" id="playButton">Play</button>
        <button class="circle-btn win-btn" id="winButton">Win</button>
        <div class="dashboard-center">
            <h2>Welcome, <span id="userDisplay"></span></h2>
            <div id="verifyEmailPrompt" style="display: none;">
                <p style="color: #ff5733; text-shadow: 0 0 5px #ff5733; margin-bottom: 5%;">
                    Please verify your email to play. Check your inbox!
                </p>
                <button id="resendVerification">Resend Verification Email</button>
            </div>
            <button id="logoutButton">Logout</button>
        </div>
    </div>

    <!-- Profile Page -->
    <div class="container profile-page" id="profilePage">
        <h2>Profile</h2>
        <div class="profile-content">
            <div id="profilePicCircle" class="profile-pic-circle"></div>
            <input type="file" id="profilePicInput" accept="image/png,image/jpeg">
            <div class="username-container">
                <span id="usernameDisplay" class="username-display" contenteditable="false">Set Username</span>
                <span class="edit-icon">✏</span>
            </div>
        </div>
        <button class="game-history-btn" id="gameHistoryBtn">Game History</button>
        <button id="backToDashboardFromProfile">Go to Dashboard</button>
    </div>

    <!-- Game History Page -->
    <div class="container game-history-page" id="gameHistoryPage">
        <h2>Game History</h2>
        <div class="history-container" id="historyContainer"></div>
        <div class="stats-summary" id="statsSummary"></div>
        <button id="backToProfile">Go to Profile</button>
    </div>

    <!-- Friends Page -->
    <div class="container friends-page" id="friendsPage">
        <h2>Friends</h2>
        <div class="tabs">
            <button class="tab-btn active" data-tab="friends">Friends</button>
            <button class="tab-btn" data-tab="add-friend">Add Friend</button>
            <button class="tab-btn" data-tab="requests">Friend Requests</button>
        </div>
        <div class="tab-content active" id="friendsTab">
            <div class="friends-list" id="friendsList"></div>
        </div>
        <div class="tab-content" id="addFriendTab">
            <div class="input-box">
                <input type="text" id="friendSearch" placeholder="Enter username">
            </div>
            <button id="searchFriend">Search</button>
            <div id="searchResults"></div>
        </div>
        <div class="tab-content" id="requestsTab">
            <div id="friendRequests"></div>
        </div>
        <button id="backToDashboardFromFriends">Go to Dashboard</button>
    </div>

    <!-- Game Page -->
    <div class="container game-page" id="gamePage">
        <h2>Play Tic-Tac-Toe</h2>
        <button id="playRandom">Play with Random Player</button>
        <button id="backToDashboard">Back to Dashboard</button>
    </div>

    <!-- Game Room -->
    <div class="container game-room" id="gameRoom">
        <h2>Tic-Tac-Toe</h2>
        <p class="room-id" id="roomIdDisplay"></p>
        <p class="status" id="gameStatus">Waiting for opponent...</p>
        <p id="playersDisplay"></p>
        <div class="game-board" id="gameBoard">
            <div class="cell" data-index="0"></div>
            <div class="cell" data-index="1"></div>
            <div class="cell" data-index="2"></div>
            <div class="cell" data-index="3"></div>
            <div class="cell" data-index="4"></div>
            <div class="cell" data-index="5"></div>
            <div class="cell" data-index="6"></div>
            <div class="cell" data-index="7"></div>
            <div class="cell" data-index="8"></div>
        </div>
        <button id="leaveRoom">Leave Room</button>
    </div>

    <!-- Waiting Area -->
    <div class="container waiting-area" id="waitingArea">
        <h2>Matchmaking</h2>
        <p>Searching for opponent...</p>
    </div>

    <!-- JavaScript and Firebase Rules will follow in subsequent parts -->
    <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-app.js";
    import { 
        getAuth, 
        createUserWithEmailAndPassword, 
        signInWithEmailAndPassword, 
        onAuthStateChanged, 
        signOut, 
        sendEmailVerification 
    } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-auth.js";
    import { 
        getFirestore, 
        doc, 
        setDoc, 
        getDoc, 
        onSnapshot, 
        updateDoc, 
        deleteDoc, 
        collection, 
        addDoc, 
        query, 
        where, 
        getDocs, 
        serverTimestamp 
    } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-firestore.js";
    import { 
        getStorage, 
        ref, 
        uploadBytes, 
        getDownloadURL 
    } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-storage.js";

    // For Firebase JS SDK v7.20.0 and later, measurementId is optional
const firebaseConfig = {
  apiKey: "AIzaSyAol2UzQWdFPyTeWhlfK7HTXxMpsuXnSFk",
  authDomain: "final-78170.firebaseapp.com",
  projectId: "final-78170",
  storageBucket: "final-78170.firebasestorage.app",
  messagingSenderId: "374288155367",
  appId: "1:374288155367:web:94a49f3b204dfa2efc5842",
  measurementId: "G-9GM80JWP3C"
};

    let auth, db, storage;
    try {
        const app = initializeApp(firebaseConfig);
        auth = getAuth(app);
        db = getFirestore(app);
        storage = getStorage(app);
        console.log('Firebase initialized successfully');
    } catch (error) {
        console.error('Firebase initialization error:', error);
        showMessage('Failed to initialize Firebase. Check console and verify configuration.', 'error');
    }

    // DOM Elements
    const authContainer = document.getElementById('authContainer');
    const dashboard = document.getElementById('dashboard');
    const profilePage = document.getElementById('profilePage');
    const gameHistoryPage = document.getElementById('gameHistoryPage');
    const friendsPage = document.getElementById('friendsPage');
    const gamePage = document.getElementById('gamePage');
    const gameRoom = document.getElementById('gameRoom');
    const waitingArea = document.getElementById('waitingArea');
    const formTitle = document.getElementById('formTitle');
    const authButton = document.getElementById('authButton');
    const toggleAuth = document.getElementById('toggleAuth');
    const emailInput = document.getElementById('email');
    const passwordInput = document.getElementById('password');
    const usernameInput = document.getElementById('username');
    const userDisplay = document.getElementById('userDisplay');
    const usernameDisplay = document.getElementById('usernameDisplay');
    const profilePicCircle = document.getElementById('profilePicCircle');
    const profilePicInput = document.getElementById('profilePicInput');
    const gameHistoryBtn = document.getElementById('gameHistoryBtn');
    const backToDashboardFromProfile = document.getElementById('backToDashboardFromProfile');
    const historyContainer = document.getElementById('historyContainer');
    const statsSummary = document.getElementById('statsSummary');
    const backToProfile = document.getElementById('backToProfile');
    const playButton = document.getElementById('playButton');
    const winButton = document.getElementById('winButton');
    const friendsBtn = document.getElementById('friendsBtn');
    const logoutButton = document.getElementById('logoutButton');
    const playRandom = document.getElementById('playRandom');
    const backToDashboard = document.getElementById('backToDashboard');
    const roomIdDisplay = document.getElementById('roomIdDisplay');
    const gameStatus = document.getElementById('gameStatus');
    const gameBoard = document.getElementById('gameBoard');
    const leaveRoom = document.getElementById('leaveRoom');
    const playersDisplay = document.getElementById('playersDisplay');
    const verifyEmailPrompt = document.getElementById('verifyEmailPrompt');
    const resendVerification = document.getElementById('resendVerification');
    const profileBtn = document.getElementById('profileBtn');
    const friendsTab = document.getElementById('friendsTab');
    const addFriendTab = document.getElementById('addFriendTab');
    const requestsTab = document.getElementById('requestsTab');
    const friendsList = document.getElementById('friendsList');
    const friendSearch = document.getElementById('friendSearch');
    const searchFriend = document.getElementById('searchFriend');
    const searchResults = document.getElementById('searchResults');
    const friendRequests = document.getElementById('friendRequests');
    const backToDashboardFromFriends = document.getElementById('backToDashboardFromFriends');

    // Initialize container visibility
    function initializeContainers() {
        console.log('Initializing containers');
        const containers = [authContainer, dashboard, profilePage, gameHistoryPage, friendsPage, gamePage, gameRoom, waitingArea];
        containers.forEach(c => c && (c.style.display = 'none'));
        authContainer.style.display = 'block';
    }
    initializeContainers();

    let isSignUp = true;
    let currentRoomId = null;
    let currentPlayer = null;
    let opponentUsername = null;
    let unsubscribeRoom = null;
    let lastSaveTime = 0;

    // Show Message
    function showMessage(message, type) {
        console.log(`Showing message: ${message} (${type})`);
        const msgDiv = document.createElement('div');
        msgDiv.className = `message ${type}`;
        msgDiv.textContent = message;
        document.body.appendChild(msgDiv);
        msgDiv.style.opacity = '1';
        setTimeout(() => {
            msgDiv.style.opacity = '0';
            setTimeout(() => msgDiv.remove(), 300);
        }, 3000);
    }

    // Show/Hide Containers
    function showContainer(container) {
        console.log(`Showing container: ${container?.id || 'unknown'}`);
        const containers = [authContainer, dashboard, profilePage, gameHistoryPage, friendsPage, gamePage, gameRoom, waitingArea];
        containers.forEach(c => c && (c.style.display = 'none'));
        container.style.display = 'block';
    }

    // Update Profile Circle and Button
    function updateProfileUI(username, avatarUrl) {
        console.log(`Updating profile UI: username=${username}, avatarUrl=${avatarUrl}`);
        if (!profileBtn || !profilePicCircle) {
            console.error('Profile elements not found');
            return;
        }
        const firstLetter = username.charAt(0).toUpperCase() || 'P';
        const canvas = document.createElement('canvas');
        const size = 100;
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');
        ctx.beginPath();
        ctx.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2);
        ctx.fillStyle = '#c300ff';
        ctx.fill();
        ctx.font = 'bold 60px Arial';
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(firstLetter, size / 2, size / 2);
        const canvasUrl = canvas.toDataURL();
        profileBtn.style.backgroundImage = `url(${canvasUrl})`;
        profilePicCircle.style.backgroundImage = `url(${canvasUrl})`;
        profileBtn.style.color = 'transparent';
        profilePicCircle.style.color = 'transparent';
        profileBtn.style.backgroundSize = 'cover';
        profileBtn.style.border = '2px solid #c300ff';
        profilePicCircle.style.backgroundSize = 'cover';
        profilePicCircle.style.border = '2px solid #c300ff';
        userDisplay.textContent = username;
        usernameDisplay.textContent = username;
    }

    // Check Username Availability
    async function checkUsernameAvailability(username) {
        console.log(`Checking username availability: ${username}`);
        if (!username || typeof username !== 'string' || username.trim() === '') {
            return { available: false, message: 'Username cannot be empty' };
        }
        const normalizedUsername = username.toLowerCase().trim();
        const usernameDoc = await getDoc(doc(db, 'usernames', normalizedUsername));
        if (usernameDoc.exists()) {
            return { available: false, message: 'Username is already taken' };
        }
        return { available: true };
    }

    // Save Username
    async function saveUsername(userId, username) {
        console.log(`Saving username for user ${userId}: ${username}`);
        const normalizedUsername = username.toLowerCase().trim();
        const check = await checkUsernameAvailability(username);
        if (!check.available) {
            throw new Error(check.message);
        }
        const usernameRef = doc(db, 'usernames', normalizedUsername);
        await setDoc(usernameRef, {
            userId,
            createdAt: serverTimestamp()
        });
    }

    // Delete Username
    async function deleteUsername(userId, username) {
        console.log(`Deleting username for user ${userId}: ${username}`);
        const normalizedUsername = username.toLowerCase().trim();
        const usernameRef = doc(db, 'usernames', normalizedUsername);
        const usernameDoc = await getDoc(usernameRef);
        if (usernameDoc.exists() && usernameDoc.data().userId === userId) {
            await deleteDoc(usernameRef);
        }
    }

    // Save Profile to Firebase
    async function saveProfile(username, oldUsername = null) {
        const now = Date.now();
        if (now - lastSaveTime < 500) {
            console.log('Debouncing save');
            return;
        }
        lastSaveTime = now;
        console.log('Starting profile save: user=', auth.currentUser?.uid, 'username=', username);
        const user = auth.currentUser;
        if (!user) {
            console.error('No user logged in');
            showMessage('Please log in first', 'error');
            return;
        }
        if (!user.emailVerified) {
            console.error('Email not verified');
            showMessage('Please verify your email first', 'error');
            return;
        }
        try {
            const userDocRef = doc(db, 'users', user.uid);
            const userData = { 
                username,
                avatarUrl: null 
            };
            console.log('Saving to Firestore:', userData);
            await saveUsername(user.uid, username);
            if (oldUsername && oldUsername !== username) {
                await deleteUsername(user.uid, oldUsername);
            }
            await setDoc(userDocRef, {
                ...userData,
                stats: { wins: 0, losses: 0, ties: 0 }
            }, { merge: true });
            console.log('Firestore save successful: user=', user.uid);
            updateProfileUI(username, null);
            showMessage('Profile updated!', 'success');
        } catch (error) {
            console.error('Save profile error:', error.code, error.message);
            showMessage(`Error saving profile: ${error.message}`, 'error');
        }
    }

    // Profile Picture Click
    profilePicCircle?.addEventListener('click', () => {
        console.log('Profile picture clicked, opening gallery');
        profilePicInput?.click();
    });

    // Profile Picture Change
    profilePicInput?.addEventListener('change', async (e) => {
        console.log('Profile picture input changed');
        showMessage('Profile picture upload not supported yet', 'error');
        profilePicInput.value = '';
    });

    // Username Editing
    usernameDisplay?.addEventListener('click', () => {
        console.log('Username clicked, enabling edit');
        usernameDisplay.contentEditable = 'true';
        usernameDisplay.focus();
    });

    usernameDisplay?.addEventListener('blur', async () => {
        console.log('Username blur, saving');
        usernameDisplay.contentEditable = 'false';
        const newUsername = usernameDisplay.textContent.trim();
        if (!newUsername) {
            console.error('Username is empty');
            showMessage('Please enter a username', 'error');
            const userDoc = await getDoc(doc(db, 'users', auth.currentUser?.uid));
            usernameDisplay.textContent = userDoc.exists() && userDoc.data().username ? userDoc.data().username : 'Player';
            return;
        }
        const userDoc = await getDoc(doc(db, 'users', auth.currentUser.uid));
        const oldUsername = userDoc.exists() ? userDoc.data().username : null;
        await saveProfile(newUsername, oldUsername);
    });

    usernameDisplay?.addEventListener('keydown', async (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            usernameDisplay.blur();
        }
    });

    // Profile Button Click
    profileBtn?.addEventListener('click', async () => {
        console.log('Profile button clicked');
        const user = auth.currentUser;
        if (!user) {
            console.error('No user logged in');
            showMessage('Please log in first', 'error');
            showContainer(authContainer);
            return;
        }
        try {
            console.log('Loading profile: user=', user.uid);
            const userDoc = await getDoc(doc(db, 'users', user.uid));
            const username = userDoc.exists() && userDoc.data().username ? userDoc.data().username : 'Player';
            console.log('Profile loaded: username=', username);
            usernameDisplay.textContent = username;
            updateProfileUI(username, null);
            showContainer(profilePage);
        } catch (error) {
            console.error('Profile page error:', error.code, error.message);
            showMessage(`Error loading profile: ${error.message}`, 'error');
        }
    });

    // Back to Dashboard from Profile
    backToDashboardFromProfile?.addEventListener('click', () => {
        console.log('Back to dashboard from profile clicked');
        showContainer(dashboard);
    });

    // Game History Button
    gameHistoryBtn?.addEventListener('click', async () => {
        console.log('Game history clicked');
        const user = auth.currentUser;
        if (!user) {
            console.error('No user logged in');
            showMessage('Please log in first', 'error');
            showContainer(authContainer);
            return;
        }
        try {
            console.log('Loading game history: user=', user.uid);
            const userDoc = await getDoc(doc(db, 'users', user.uid));
            const stats = userDoc.exists() && userDoc.data().stats ? userDoc.data().stats : { wins: 0, losses: 0, ties: 0 };
            console.log('Stats loaded:', stats);

            const historyQuery = query(collection(db, `users/${user.uid}/gameHistory`));
            const historyDocs = await getDocs(historyQuery);
            console.log('Game history docs:', historyDocs.size);

            historyContainer.innerHTML = '';
            historyDocs.forEach(doc => {
                const game = doc.data();
                const date = game.timestamp?.toDate ? game.timestamp.toDate() : new Date();
                const formattedDate = date.toLocaleString('en-US', {
                    month: 'long',
                    day: '2-digit',
                    year: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: false
                });
                const box = document.createElement('div');
                box.className = `history-box ${game.result === 'win' ? 'win' : 'loss-tie'}`;
                box.innerHTML = `
                    <p>Opponent: ${game.opponentUsername || 'Unknown'}</p>
                    <p>Result: ${game.result.charAt(0).toUpperCase() + game.result.slice(1)}</p>
                    <p>Time: ${formattedDate}</p>
                `;
                historyContainer.appendChild(box);
            });

            statsSummary.textContent = `Total Matches: Wins ${stats.wins}, Losses ${stats.losses}, Ties ${stats.ties}`;
            showContainer(gameHistoryPage);
        } catch (error) {
            console.error('Game history error:', error.code, error.message);
            showMessage(`Error loading game history: ${error.message}`, 'error');
        }
    });

    // Back to Profile
    backToProfile?.addEventListener('click', () => {
        console.log('Back to profile clicked');
        showContainer(profilePage);
    });

    // Friends Button
    friendsBtn?.addEventListener('click', async () => {
        console.log('Friends button clicked');
        const user = auth.currentUser;
        if (!user) {
            console.error('No user logged in');
            showMessage('Please log in first', 'error');
            showContainer(authContainer);
            return;
        }
        try {
            console.log('Loading friends page: user=', user.uid);
            showContainer(friendsPage);
            loadFriendsTab();
        } catch (error) {
            console.error('Friends page error:', error.code, error.message);
            showMessage(`Error loading friends: ${error.message}`, 'error');
        }
    });

    // Tab Switching
    document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            console.log(`Tab clicked: ${btn.dataset.tab}`);
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            btn.classList.add('active');
            document.getElementById(`${btn.dataset.tab}Tab`).classList.add('active');
            if (btn.dataset.tab === 'friends') loadFriendsTab();
            else if (btn.dataset.tab === 'add-friend') loadAddFriendTab();
            else if (btn.dataset.tab === 'requests') loadRequestsTab();
        });
    });

    // Load Friends Tab
    async function loadFriendsTab() {
        console.log('Loading friends tab');
        const user = auth.currentUser;
        if (!user) {
            showMessage('Please log in first', 'error');
            return;
        }
        try {
            friendsList.innerHTML = '';
            const friendsQuery = query(collection(db, `users/${user.uid}/friends`));
            const friendsDocs = await getDocs(friendsQuery);
            if (friendsDocs.empty) {
                friendsList.innerHTML = '<p style="color: #ff5733; text-shadow: 0 0 5px #ff5733;">No friends yet.</p>';
                return;
            }
            friendsDocs.forEach(doc => {
                const friend = doc.data();
                const friendBox = document.createElement('div');
                friendBox.className = 'friend-box';
                friendBox.innerHTML = `
                    <p>Username: ${friend.username}</p>
                    <button class="action-btn" data-friend-id="${doc.id}" data-username="${friend.username}">Remove Friend</button>
                `;
                friendsList.appendChild(friendBox);
            });

            // Remove Friend
            friendsList.querySelectorAll('.action-btn').forEach(btn => {
                btn.addEventListener('click', async () => {
                    console.log(`Remove friend clicked: ${btn.dataset.friendId}`);
                    try {
                        const friendId = btn.dataset.friendId;
                        const friendUsername = btn.dataset.username;
                        const friendDoc = await getDoc(doc(db, 'usernames', friendUsername.toLowerCase()));
                        if (friendDoc.exists()) {
                            const friendUserId = friendDoc.data().userId;
                            await deleteDoc(doc(db, `users/${user.uid}/friends`, friendId));
                            await deleteDoc(doc(db, `users/${friendUserId}/friends`, user.uid));
                            showMessage(`Removed ${friendUsername} from friends`, 'success');
                            loadFriendsTab();
                        }
                    } catch (error) {
                        console.error('Remove friend error:', error);
                        showMessage(`Error removing friend: ${error.message}`, 'error');
                    }
                });
            });
        } catch (error) {
            console.error('Load friends error:', error);
            showMessage(`Error loading friends: ${error.message}`, 'error');
        }
    }

    // Load Add Friend Tab
    async function loadAddFriendTab() {
        console.log('Loading add friend tab');
        searchResults.innerHTML = '';
        friendSearch.value = '';
    }

    // Search Friend
    searchFriend?.addEventListener('click', async () => {
        console.log('Search friend clicked');
        const searchTerm = friendSearch.value.trim();
        if (!searchTerm) {
            showMessage('Please enter a username', 'error');
            return;
        }
        try {
            const usernameDoc = await getDoc(doc(db, 'usernames', searchTerm.toLowerCase()));
            if (!usernameDoc.exists()) {
                searchResults.innerHTML = '<p style="color: #ff5733; text-shadow: 0 0 5px #ff5733;">User not found.</p>';
                return;
            }
            const user = auth.currentUser;
            const foundUserId = usernameDoc.data().userId;
            if (foundUserId === user.uid) {
                searchResults.innerHTML = '<p style="color: #ff5733; text-shadow: 0 0 5px #ff5733;">You cannot add yourself.</p>';
                return;
            }
            const friendDoc = await getDoc(doc(db, `users/${user.uid}/friends`, foundUserId));
            if (friendDoc.exists()) {
                searchResults.innerHTML = '<p style="color: #ff5733; text-shadow: 0 0 5px #ff5733;">Already friends.</p>';
                return;
            }
            const outgoingRequestQuery = query(
                collection(db, `users/${user.uid}/friendRequests`),
                where('toUserId', '==', foundUserId),
                where('status', '==', 'pending')
            );
            const incomingRequestQuery = query(
                collection(db, `users/${user.uid}/friendRequests`),
                where('fromUserId', '==', foundUserId),
                where('status', '==', 'pending')
            );
            const [outgoingDocs, incomingDocs] = await Promise.all([
                getDocs(outgoingRequestQuery),
                getDocs(incomingRequestQuery)
            ]);
            if (!outgoingDocs.empty) {
                searchResults.innerHTML = '<p style="color: #ff5733; text-shadow: 0 0 5px #ff5733;">Request already sent.</p>';
                return;
            }
            if (!incomingDocs.empty) {
                searchResults.innerHTML = '<p style="color: #ff5733; text-shadow: 0 0 5px #ff5733;">Check pending requests.</p>';
                return;
            }
            searchResults.innerHTML = '';
            const resultBox = document.createElement('div');
            resultBox.className = 'result-box';
            resultBox.innerHTML = `
                <p>Username: ${searchTerm}</p>
                <button class="action-btn" data-user-id="${foundUserId}" data-username="${searchTerm}">Send Friend Request</button>
            `;
            searchResults.appendChild(resultBox);

            // Send Friend Request
            resultBox.querySelector('.action-btn').addEventListener('click', async () => {
                console.log(`Send friend request to: ${searchTerm}`);
                try {
                    const userDoc = await getDoc(doc(db, 'users', user.uid));
                    const fromUsername = userDoc.data().username;
                    const requestData = {
                        fromUserId: user.uid,
                        fromUsername,
                        toUserId: foundUserId,
                        toUsername: searchTerm,
                        status: 'pending',
                        createdAt: serverTimestamp()
                    };
                    const requestRef = await addDoc(collection(db, `users/${foundUserId}/friendRequests`), requestData);
                    await setDoc(doc(db, `users/${user.uid}/friendRequests`, requestRef.id), requestData);
                    showMessage(`Friend request sent to ${searchTerm}!`, 'success');
                    searchResults.innerHTML = '';
                    friendSearch.value = '';
                } catch (error) {
                    console.error('Send friend request error:', error);
                    showMessage(`Error sending request: ${error.message}`, 'error');
                }
            });
        } catch (error) {
            console.error('Search friend error:', error);
            showMessage(`Error searching user: ${error.message}`, 'error');
        }
    });

    // Load Friend Requests Tab
    async function loadRequestsTab() {
        console.log('Loading friend requests tab');
        const user = auth.currentUser;
        if (!user) {
            showMessage('Please log in first', 'error');
            return;
        }
        try {
            friendRequests.innerHTML = '';
            const requestsQuery = query(
                collection(db, `users/${user.uid}/friendRequests`),
                where('toUserId', '==', user.uid),
                where('status', '==', 'pending')
            );
            const requestsDocs = await getDocs(requestsQuery);
            if (requestsDocs.empty) {
                friendRequests.innerHTML = '<p style="color: #ff5733; text-shadow: 0 0 5px #ff5733;">No pending requests.</p>';
                return;
            }
            requestsDocs.forEach(doc => {
                const request = doc.data();
                const requestBox = document.createElement('div');
                requestBox.className = 'request-box';
                requestBox.innerHTML = `
                    <p>From: ${request.fromUsername}</p>
                    <button class="action-btn accept-btn" data-request-id="${doc.id}" data-from-id="${request.fromUserId}" data-from-username="${request.fromUsername}">Accept</button>
                    <button class="action-btn reject-btn" data-request-id="${doc.id}" data-from-id="${request.fromUserId}" data-from-username="${request.fromUsername}">Reject</button>
                `;
                friendRequests.appendChild(requestBox);
            });

            // Accept Request
            friendRequests.querySelectorAll('.accept-btn').forEach(btn => {
                btn.addEventListener('click', async () => {
                    console.log(`Accept request: ${btn.dataset.requestId}`);
                    try {
                        const requestId = btn.dataset.requestId;
                        const fromId = btn.dataset.fromId;
                        const fromUsername = btn.dataset.fromUsername;
                        const userDoc = await getDoc(doc(db, 'users', user.uid));
                        const toUsername = userDoc.data().username;
                        await setDoc(doc(db, `users/${user.uid}/friends`, fromId), {
                            username: fromUsername,
                            addedAt: serverTimestamp()
                        });
                        await setDoc(doc(db, `users/${fromId}/friends`, user.uid), {
                            username: toUsername,
                            addedAt: serverTimestamp()
                        });
                        await updateDoc(doc(db, `users/${user.uid}/friendRequests`, requestId), { status: 'accepted' });
                        await updateDoc(doc(db, `users/${fromId}/friendRequests`, requestId), { status: 'accepted' });
                        showMessage(`You are now friends with ${fromUsername}!`, 'success');
                        loadRequestsTab();
                    } catch (error) {
                        console.error('Accept request error:', error);
                        showMessage(`Error accepting request: ${error.message}`, 'error');
                    }
                });
            });

            // Reject Request
            friendRequests.querySelectorAll('.reject-btn').forEach(btn => {
                btn.addEventListener('click', async () => {
                    console.log(`Reject request: ${btn.dataset.requestId}`);
                    try {
                        const requestId = btn.dataset.requestId;
                        const fromId = btn.dataset.fromId;
                        const fromUsername = btn.dataset.fromUsername;
                        await updateDoc(doc(db, `users/${user.uid}/friendRequests`, requestId), { status: 'rejected' });
                        await updateDoc(doc(db, `users/${fromId}/friendRequests`, requestId), { status: 'rejected' });
                        showMessage(`Rejected request from ${fromUsername}`, 'success');
                        loadRequestsTab();
                    } catch (error) {
                        console.error('Reject request error:', error);
                        showMessage(`Error rejecting request: ${error.message}`, 'error');
                    }
                });
            });
        } catch (error) {
            console.error('Load requests error:', error);
            showMessage(`Error loading requests: ${error.message}`, 'error');
        }
    }

    // Back to Dashboard from Friends
    backToDashboardFromFriends?.addEventListener('click', () => {
        console.log('Back to dashboard from friends clicked');
        showContainer(dashboard);
    });

    // Toggle Auth Mode
    toggleAuth.addEventListener('click', () => {
        console.log('Toggle auth clicked');
        isSignUp = !isSignUp;
        formTitle.textContent = isSignUp ? 'Sign Up' : 'Login';
        authButton.textContent = isSignUp ? 'Sign Up' : 'Login';
        toggleAuth.textContent = isSignUp ? 'Already have an account? Login' : 'Need an account? Sign Up';
        usernameInput.style.display = isSignUp ? 'block' : 'none';
        usernameInput.parentElement.style.display = isSignUp ? 'block' : 'none';
    });

    // Authentication Handler
    authButton.addEventListener('click', async () => {
        console.log('Auth button clicked');
        const email = emailInput?.value;
        const password = passwordInput?.value;
        const username = isSignUp ? usernameInput?.value : null;
        if (!email || !password) {
            console.error('Email or password missing');
            showMessage('Please enter email and password', 'error');
            return;
        }
        if (isSignUp && !username) {
            console.error('Username missing');
            showMessage('Please enter a username', 'error');
            return;
        }
        try {
            if (isSignUp) {
                const check = await checkUsernameAvailability(username);
                if (!check.available) {
                    showMessage(check.message, 'error');
                    return;
                }
                const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                await sendEmailVerification(userCredential.user);
                await saveProfile(username);
                showMessage('Sign Up Successful! Please verify your email.', 'success');
            } else {
                await signInWithEmailAndPassword(auth, email, password);
                showMessage('Login Successful!', 'success');
            }
            emailInput.value = '';
            passwordInput.value = '';
            usernameInput.value = '';
        } catch (error) {
            console.error('Auth error:', error.code, error.message);
            showMessage(`Error: ${error.message}`, 'error');
        }
    });

    // Resend Verification Email
    resendVerification?.addEventListener('click', async () => {
        console.log('Resend verification clicked');
        const user = auth.currentUser;
        if (user && !user.emailVerified) {
            try {
                await sendEmailVerification(user);
                showMessage('Verification email resent! Check your inbox.', 'success');
            } catch (error) {
                console.error('Resend verification error:', error.code, error.message);
                showMessage(`Error: ${error.message}`, 'error');
            }
        }
    });

    // Play Button
    playButton.addEventListener('click', async () => {
        console.log('Play button clicked');
        const user = auth.currentUser;
        if (!user) {
            console.error('No user logged in');
            showMessage('Please log in first', 'error');
            showContainer(authContainer);
            return;
        }
        if (!user.emailVerified) {
            console.error('Email not verified');
            showMessage('Please verify your email first', 'error');
            return;
        }
        try {
            const userDoc = await getDoc(doc(db, 'users', user.uid));
            if (userDoc.exists() && userDoc.data().username) {
                showContainer(gamePage);
            } else {
                console.log('No username set, redirecting to profile');
                showMessage('Please set a username first', 'error');
                showContainer(profilePage);
            }
        } catch (error) {
            console.error('Play button error:', error.code, error.message);
            showMessage(`Error: ${error.message}`, 'error');
        }
    });

    // Back to Dashboard
    backToDashboard.addEventListener('click', () => {
        console.log('Back to dashboard clicked');
        if (!auth.currentUser) {
            console.error('No user logged in');
            showMessage('Please log in first', 'error');
            showContainer(authContainer);
            return;
        }
        showContainer(dashboard);
    });

    // Play with Random Player
    playRandom.addEventListener('click', async () => {
        console.log('Play random clicked');
        const user = auth.currentUser;
        if (!user || !user.emailVerified) {
            console.error('User not logged in or email not verified');
            showMessage('Please verify your email first', 'error');
            showContainer(authContainer);
            return;
        }
        console.log('Starting matchmaking for user:', user.uid);
        let matchmakingId = null;
        try {
            const userDoc = await getDoc(doc(db, 'users', user.uid));
            const username = userDoc.data()?.username || 'Player';
            showContainer(waitingArea);

            // Clean up existing matchmaking entries
            const userEntries = await getDocs(query(collection(db, 'matchmaking'), where('userId', '==', user.uid)));
            for (const entry of userEntries.docs) {
                console.log('Deleting stale entry:', entry.id);
                await deleteDoc(doc(db, 'matchmaking', entry.id));
            }

            // Add to matchmaking pool
            const matchmakingData = {
                userId: user.uid,
                username,
                status: 'waiting',
                timestamp: Date.now()
            };
            const matchmakingRef = await addDoc(collection(db, 'matchmaking'), matchmakingData);
            matchmakingId = matchmakingRef.id;
            console.log('Added to matchmaking pool:', matchmakingId);

            // Listen for matchmaking entry
            let isPaired = false;
            const unsubscribeMatch = onSnapshot(doc(db, 'matchmaking', matchmakingId), async snapshot => {
                if (!snapshot.exists()) {
                    if (!isPaired) {
                        console.log('Matchmaking entry deleted unexpectedly');
                        showContainer(gamePage);
                        showMessage('Matchmaking canceled.', 'error');
                    }
                    return;
                }
                const data = snapshot.data();
                console.log('Matchmaking entry updated:', data);
                if (data.status === 'paired' && data.roomId) {
                    isPaired = true;
                    currentRoomId = data.roomId;
                    currentPlayer = data.playerSymbol || 'O';
                    opponentUsername = data.opponentUsername;
                    await deleteDoc(doc(db, 'matchmaking', matchmakingId));
                    unsubscribeMatch();
                    showContainer(gameRoom);
                    roomIdDisplay.textContent = `Room ID: ${currentRoomId}`;
                    listenToRoom(currentRoomId, username);
                    showMessage('Opponent found! Game started.', 'success');
                }
            }, error => {
                console.error('Matchmaking listener error:', error);
                showMessage('Matchmaking failed. Please try again.', 'error');
                if (matchmakingId) {
                    deleteDoc(doc(db, 'matchmaking', matchmakingId)).catch(err => console.error('Cleanup error:', err));
                }
                unsubscribeMatch();
                showContainer(gamePage);
            });

            // Check for unpaired players
            const now = Date.now();
            const q = query(collection(db, 'matchmaking'), where('status', '==', 'waiting'));
            const existingEntries = await getDocs(q);
            console.log('Existing matchmaking entries:', existingEntries.size);

            const opponentDocs = existingEntries.docs.filter(doc => doc.id !== matchmakingId);
            if (opponentDocs.length > 0) {
                const opponentDoc = opponentDocs[0];
                const opponentData = opponentDoc.data();
                console.log('Found opponent:', opponentData.userId);

                const roomData = {
                    player1: user.uid,
                    player1Username: username,
                    player2: opponentData.userId,
                    player2Username: opponentData.username,
                    board: ['', '', '', '', '', '', '', '', ''],
                    currentTurn: 'X',
                    status: 'active',
                    createdAt: serverTimestamp()
                };
                const roomRef = await addDoc(collection(db, 'rooms'), roomData);
                currentRoomId = roomRef.id;
                console.log('Created room:', currentRoomId);

                await updateDoc(doc(db, 'matchmaking', opponentDoc.id), {
                    status: 'paired',
                    roomId: currentRoomId,
                    playerSymbol: 'X',
                    opponentUsername: username
                });

                await updateDoc(doc(db, 'matchmaking', matchmakingId), {
                    status: 'paired',
                    roomId: currentRoomId,
                    playerSymbol: 'O',
                    opponentUsername: opponentData.username
                });
            }
        } catch (error) {
            console.error('Matchmaking error:', error);
            showMessage('Failed to find opponent. Please try again.', 'error');
            if (matchmakingId) {
                await deleteDoc(doc(db, 'matchmaking', matchmakingId)).catch(err => console.error('Cleanup error:', err));
            }
            showContainer(gamePage);
        }
    });

    // Listen to Game Room
    function listenToRoom(roomId, username) {
        console.log(`Listening to room: ${roomId}`);
        const roomRef = doc(db, 'rooms', roomId);
        unsubscribeRoom = onSnapshot(roomRef, async snapshot => {
            if (!snapshot.exists()) {
                console.log('Room deleted or does not exist');
                showContainer(gamePage);
                showMessage('Game room closed.', 'error');
                cleanupRoom();
                return;
            }
            const data = snapshot.data();
            console.log('Room data:', data);
            updateGameBoard(data.board);
            playersDisplay.textContent = `You (${username}) vs ${opponentUsername}`;
            gameStatus.textContent = data.status === 'active' ? 
                (data.currentTurn === currentPlayer ? 'Your turn!' : `Waiting for ${opponentUsername}'s move...`) : 
                data.status;

            if (data.status !== 'active') {
                await handleGameEnd(data.status, username);
            }
        }, error => {
            console.error('Room listener error:', error);
            showMessage('Error in game room. Returning to game page.', 'error');
            cleanupRoom();
            showContainer(gamePage);
        });
    }

    // Update Game Board
    function updateGameBoard(board) {
        console.log('Updating game board:', board);
        const cells = gameBoard.querySelectorAll('.cell');
        cells.forEach((cell, index) => {
            cell.textContent = board[index];
            cell.className = 'cell';
            if (board[index] === 'X') {
                cell.classList.add('x');
            } else if (board[index] === 'O') {
                cell.classList.add('o');
            }
        });
    }

    // Handle Game Move
    gameBoard.addEventListener('click', async (e) => {
        const cell = e.target.closest('.cell');
        if (!cell) return;
        const index = cell.dataset.index;
        console.log(`Cell clicked: ${index}`);
        const user = auth.currentUser;
        if (!user || !currentRoomId || !currentPlayer) {
            console.error('Invalid game state');
            showMessage('Game state error.', 'error');
            return;
        }
        try {
            const roomRef = doc(db, 'rooms', currentRoomId);
            const roomDoc = await getDoc(roomRef);
            if (!roomDoc.exists()) {
                console.log('Room does not exist');
                showMessage('Game room closed.', 'error');
                cleanupRoom();
                showContainer(gamePage);
                return;
            }
            const data = roomDoc.data();
            if (data.status !== 'active' || data.currentTurn !== currentPlayer || data.board[index] !== '') {
                console.log('Invalid move');
                return;
            }
            const newBoard = [...data.board];
            newBoard[index] = currentPlayer;
            const newTurn = currentPlayer === 'X' ? 'O' : 'X';
            await updateDoc(roomRef, {
                board: newBoard,
                currentTurn: newTurn
            });
            console.log('Move submitted:', newBoard);
        } catch (error) {
            console.error('Move error:', error);
            showMessage('Error making move.', 'error');
        }
    });

    // Handle Game End
    async function handleGameEnd(status, username) {
        console.log(`Game ended: ${status}`);
        const user = auth.currentUser;
        if (!user) return;
        try {
            const userDocRef = doc(db, 'users', user.uid);
            const userDoc = await getDoc(userDocRef);
            const stats = userDoc.exists() && userDoc.data().stats ? userDoc.data().stats : { wins: 0, losses: 0, ties: 0 };
            let result = 'tie';
            if (status === `${currentPlayer} wins`) {
                result = 'win';
                stats.wins += 1;
            } else if (status.includes('wins') && !status.includes(currentPlayer)) {
                result = 'loss';
                stats.losses += 1;
            } else {
                stats.ties += 1;
            }
            await setDoc(userDocRef, { stats }, { merge: true });
            await addDoc(collection(db, `users/${user.uid}/gameHistory`), {
                opponentUsername,
                result,
                timestamp: serverTimestamp()
            });
            showMessage(`Game Over! Result: ${result.charAt(0).toUpperCase() + result.slice(1)}`, result === 'win' ? 'success' : 'error');
            cleanupRoom();
            showContainer(gamePage);
        } catch (error) {
            console.error('Game end error:', error);
            showMessage('Error processing game result.', 'error');
        }
    }

    // Cleanup Room
    function cleanupRoom() {
        console.log('Cleaning up room');
        if (unsubscribeRoom) {
            unsubscribeRoom();
            unsubscribeRoom = null;
        }
        currentRoomId = null;
        currentPlayer = null;
        opponentUsername = null;
    }

    // Leave Room
    leaveRoom.addEventListener('click', async () => {
        console.log('Leave room clicked');
        if (!currentRoomId) {
            console.log('No active room');
            showContainer(gamePage);
            return;
        }
        try {
            const roomRef = doc(db, 'rooms', currentRoomId);
            await updateDoc(roomRef, { status: 'abandoned' });
            cleanupRoom();
            showContainer(gamePage);
            showMessage('You left the game.', 'error');
        } catch (error) {
            console.error('Leave room error:', error);
            showMessage('Error leaving game.', 'error');
            cleanupRoom();
            showContainer(gamePage);
        }
    });

    // Logout
    logoutButton.addEventListener('click', async () => {
        console.log('Logout clicked');
        try {
            await signOut(auth);
            showMessage('Logged out successfully!', 'success');
            showContainer(authContainer);
            initializeContainers();
        } catch (error) {
            console.error('Logout error:', error);
            showMessage(`Error: ${error.message}`, 'error');
        }
    });

    // Auth State Listener
    onAuthStateChanged(auth, async user => {
        console.log('Auth state changed:', user ? user.uid : 'No user');
        if (user) {
            try {
                const userDoc = await getDoc(doc(db, 'users', user.uid));
                const username = userDoc.exists() && userDoc.data().username ? userDoc.data().username : 'Player';
                console.log('User data loaded: username=', username);
                updateProfileUI(username, null);
                verifyEmailPrompt.style.display = user.emailVerified ? 'none' : 'block';
                showContainer(dashboard);
            } catch (error) {
                console.error('User data load error:', error);
                showMessage('Error loading user data.', 'error');
                await signOut(auth);
                showContainer(authContainer);
            }
        } else {
            initializeContainers();
        }
    });
</script>
</body>
</html>
