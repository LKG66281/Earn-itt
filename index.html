<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Tic-Tac-Toe</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Impact', sans-serif;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(45deg, #1a0000, #001a00, #00001a);
            background-size: 600%;
            animation: dangerGlow 10s ease infinite;
            overflow-x: hidden;
        }

        @keyframes dangerGlow {
            0% { background-position: 0% 50%; }
            50% { background-position: 400% 50%; }
            100% { background-position: 0% 50%; }
        }

        .container {
            background: rgba(0, 0, 0, 0.95);
            padding: 5%;
            border-radius: 15px;
            border: 2px solid #ff004d;
            box-shadow: 0 0 40px #ff004d, 0 0 60px #00ff4d;
            width: min(90%, 500px);
            text-align: center;
            position: relative;
            z-index: 1;
        }

        h2 {
            color: #ff004d;
            text-shadow: 0 0 20px #ff004d, 0 0 30px #00ff4d, 0 0 40px #4d00ff;
            margin-bottom: 5%;
            font-size: clamp(1.8rem, 6vw, 2.2rem);
            animation: colorPulse 3s infinite;
        }

        @keyframes colorPulse {
            0% { color: #ff004d; }
            33% { color: #00ff4d; }
            66% { color: #4d00ff; }
            100% { color: #ff004d; }
        }

        .input-box {
            margin-bottom: 5%;
            width: 80%;
            margin-left: auto;
            margin-right: auto;
        }

        input[type="text"], input[type="file"], input[type="email"], input[type="password"] {
            width: 100%;
            padding: 3%;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid #00ff4d;
            outline: none;
            border-radius: 10px;
            color: #fff;
            font-size: clamp(0.9rem, 3vw, 1rem);
            box-shadow: 0 0 15px #00ff4d;
            transition: box-shadow 0.3s ease, border-color 0.3s ease;
        }

        input[type="file"] {
            display: none;
        }

        input:focus {
            box-shadow: 0 0 30px #ff004d, 0 0 40px #4d00ff;
            border-color: #4d00ff;
        }

        button {
            width: 100%;
            padding: 3%;
            background: linear-gradient(45deg, #ff0057, #00ff57, #5700ff);
            background-size: 300%;
            border: 2px solid #fff;
            border-radius: 5px;
            color: #fff;
            font-size: clamp(0.9rem, 3vw, 1rem);
            cursor: pointer;
            text-shadow: 0 0 10px #fff;
            box-shadow: 0 0 20px #ff0057, 0 0 30px #00ff57;
            transition: all 0.3s ease;
            margin-bottom: 3%;
            animation: buttonPulse 1.5s infinite;
        }

        @keyframes buttonPulse {
            0% { transform: scale(1); box-shadow: 0 0 20px #ff0057; }
            50% { transform: scale(1.05); box-shadow: 0 0 40px #00ff57; }
            100% { transform: scale(1); box-shadow: 0 0 20px #ff0057; }
        }

        button:hover {
            box-shadow: 0 0 50px #5700ff, 0 0 70px #ff0057;
            background-position: 100% 50%;
        }

        .toggle-text {
            color: #00ff4d;
            cursor: pointer;
            margin-top: 3%;
            display: inline-block;
            text-shadow: 0 0 10px #00ff4d;
            font-size: clamp(0.8rem, 2.5vw, 0.9rem);
        }

        .toggle-text:hover {
            text-decoration: underline;
            text-shadow: 0 0 20px #ff0057;
        }

        .message {
            position: fixed;
            top: 5%;
            right: 5%;
            padding: 3%;
            border-radius: 5px;
            color: #fff;
            font-size: clamp(0.8rem, 2.5vw, 0.9rem);
            box-shadow: 0 0 15px #ff0057;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 1000;
        }

        .message.success {
            background: #00ff57;
            text-shadow: 0 0 10px #00ff57;
        }

        .message.error {
            background: #ff0057;
            text-shadow: 0 0 10px #ff0057;
        }

        .dashboard, .game-page, .game-room, .waiting-area, .profile-page, .game-history-page, .friends-page {
            display: none;
            color: #fff;
        }

        .play-btn {
            background: linear-gradient(45deg, #ff0057, #5700ff);
            box-shadow: 0 0 20px #ff0057;
        }

        .play-btn:hover {
            box-shadow: 0 0 40px #5700ff;
        }

        .circle-btn {
            width: clamp(50px, 10vw, 60px);
            height: clamp(50px, 10vw, 60px);
            border-radius: 50%;
            background: linear-gradient(45deg, #ff0057, #00ff57, #5700ff);
            background-size: 400%;
            border: 2px solid #fff;
            color: #fff;
            font-size: clamp(1rem, 3vw, 1.2rem);
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            box-shadow: 0 0 25px #ff0057, 0 0 35px #00ff57;
            animation: buttonPulse 2s infinite;
            transition: all 0.3s ease;
        }

        .circle-btn:hover {
            box-shadow: 0 0 50px #5700ff, 0 0 70px #ff0057;
            transform: scale(1.1);
        }

        .win-btn {
            background: linear-gradient(45deg, #00ff57, #ff0057);
            box-shadow: 0 0 20px #00ff57;
        }

        .win-btn:hover {
            box-shadow: 0 0 40px #ff0057;
        }

        .friends-btn {
            background: linear-gradient(45deg, #5700ff, #ff0057);
            box-shadow: 0 0 20px #5700ff;
        }

        .friends-btn:hover {
            box-shadow: 0 0 40px #00ff57;
        }

        .game-board {
            display: grid;
            grid-template-columns: repeat(3, 30%);
            gap: 2%;
            margin: 5% auto;
            width: 90%;
        }

        .cell {
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.05);
            border: 3px solid #5700ff;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: clamp(2rem, 8vw, 3rem);
            color: #fff;
            cursor: pointer;
            text-shadow: 0 0 20px #00ff57;
            transition: all 0.3s ease;
        }

        .cell:hover {
            background: rgba(255, 255, 255, 0.2);
            box-shadow: 0 0 30px #ff0057;
        }

        .cell.x {
            color: #ff0057;
            text-shadow: 0 0 25px #ff0057;
        }

        .cell.o {
            color: #00ff57;
            text-shadow: 0 0 25px #00ff57;
        }

        .room-id, .status {
            color: #5700ff;
            text-shadow: 0 0 10px #5700ff;
            margin-bottom: 5%;
            font-size: clamp(1rem, 3.5vw, 1.2rem);
        }

        .waiting-area p {
            color: #ff0057;
            text-shadow: 0 0 20px #ff0057;
            font-size: clamp(1.2rem, 4vw, 1.5rem);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.6; }
            100% { opacity: 1; }
        }

        /* Dashboard Layout */
        .dashboard {
            position: relative;
            min-height: 80vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        #profileBtn {
            position: absolute;
            top: 5%;
            right: 5%;
            background: none;
            background-size: cover;
            color: transparent;
            border: 3px solid #ff0057;
        }

        #walletBtn {
            position: absolute;
            top: 5%;
            left: 5%;
        }

        .balance-box {
            position: absolute;
            top: 5%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #00ff57;
            border-radius: 10px;
            padding: 2%;
            width: clamp(100px, 25vw, 150px);
            color: #00ff57;
            font-size: clamp(1rem, 3.5vw, 1.2rem);
            font-weight: bold;
            text-shadow: 0 0 15px #00ff57;
            box-shadow: 0 0 30px #00ff57;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #playButton {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: clamp(100px, 20vw, 120px);
            border-radius: 50%;
        }

        #winButton {
            position: absolute;
            bottom: 5%;
            left: 5%;
            width: clamp(50px, 10vw, 60px);
            height: clamp(50px, 10vw, 60px);
            border-radius: 50%;
        }

        #friendsBtn {
            position: absolute;
            bottom: 5%;
            left: 30%;
        }

        #tournamentsBtn {
            position: absolute;
            bottom: 5%;
            right: 30%;
        }

        #tasksBtn {
            position: absolute;
            bottom: 5%;
            right: 5%;
        }

        .dashboard-center {
            width: 80%;
            margin: 20% auto 10% auto;
        }

        /* Profile Page */
        .profile-page {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 5%;
        }

        .profile-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 3%;
        }

        .profile-pic-circle {
            width: clamp(80px, 20vw, 100px);
            height: clamp(80px, 20vw, 100px);
            border-radius: 50%;
            border: 3px solid #ff0057;
            margin-bottom: 3%;
            background-size: cover;
            background-position: center;
            box-shadow: 0 0 25px #ff0057;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            color: transparent;
        }

        .username-container {
            display: flex;
            align-items: center;
            margin-bottom: 5%;
        }

        .username-display {
            color: #00ff57;
            font-size: clamp(1rem, 3.5vw, 1.2rem);
            text-shadow: 0 0 15px #00ff57;
            cursor: pointer;
            padding: 2%;
            border-radius: 5px;
            transition: background 0.3s ease;
        }

        .username-display:hover {
            background: rgba(255, 0, 87, 0.3);
        }

        .edit-icon {
            color: #5700ff;
            margin-left: 2%;
            font-size: clamp(0.8rem, 2.5vw, 1rem);
            text-shadow: 0 0 10px #5700ff;
            cursor: pointer;
        }

        .game-history-btn {
            background: linear-gradient(45deg, #ff0057, #5700ff);
            width: 80%;
            padding: 3%;
            border-radius: 5px;
            box-shadow: 0 0 20px #ff0057;
        }

        .game-history-btn:hover {
            box-shadow: 0 0 40px #5700ff;
        }

        #backToDashboardFromProfile {
            width: 80%;
            margin-top: 3%;
        }

        /* Game History Page */
        .game-history-page {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 5%;
        }

        .history-container {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 5%;
        }

        .history-box {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 4%;
            text-align: center;
            transition: transform 0.3s ease;
        }

        .history-box.win {
            border: 3px solid #00ff57;
            box-shadow: 0 0 20px #00ff57;
        }

        .history-box.loss-tie {
            border: 3px solid #ff0057;
            box-shadow: 0 0 20px #ff0057;
        }

        .history-box:hover {
            transform: scale(1.05);
        }

        .history-box p {
            color: #fff;
            font-size: clamp(0.9rem, 2.5vw, 1rem);
            text-shadow: 0 0 10px #5700ff;
            margin-bottom: 2%;
        }

        .stats-summary {
            margin-bottom: 5%;
            color: #00ff57;
            font-size: clamp(1rem, 3.5vw, 1.2rem);
            text-shadow: 0 0 15px #00ff57;
        }

        #backToProfile {
            width: 80%;
            background: linear-gradient(45deg, #5700ff, #ff0057);
        }

        #backToProfile:hover {
            box-shadow: 0 0 40px #00ff57;
        }

        /* Friends Page */
        .friends-page {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 5%;
        }

        .tabs {
            display: flex;
            width: 100%;
            margin-bottom: 5%;
            gap: 2%;
        }

        .tab-btn {
            flex: 1;
            background: linear-gradient(45deg, #ff0057, #5700ff);
            border-radius: 5px;
            padding: 3%;
            font-size: clamp(0.9rem, 2.5vw, 1rem);
            cursor: pointer;
            box-shadow: 0 0 15px #ff0057;
            transition: all 0.3s ease;
        }

        .tab-btn.active {
            background: linear-gradient(45deg, #00ff57, #5700ff);
            box-shadow: 0 0 25px #00ff57;
        }

        .tab-btn:hover {
            box-shadow: 0 0 30px #5700ff;
        }

        .tab-content {
            width: 100%;
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .friends-list, #searchResults, #friendRequests {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .friend-box, .result-box, .request-box {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 4%;
            border: 3px solid #00ff57;
            box-shadow: 0 0 20px #00ff57;
            transition: transform 0.3s ease;
        }

        .friend-box:hover, .result-box:hover, .request-box:hover {
            transform: scale(1.05);
        }

        .friend-box p, .result-box p, .request-box p {
            color: #fff;
            font-size: clamp(0.9rem, 2.5vw, 1rem);
            text-shadow: 0 0 10px #5700ff;
            margin-bottom: 2%;
        }

        .action-btn {
            width: 80%;
            margin: 2% auto;
            background: linear-gradient(45deg, #ff0057, #5700ff);
            box-shadow: 0 0 15px #ff0057;
        }

        .action-btn:hover {
            box-shadow: 0 0 30px #00ff57;
        }

        #searchFriend, #backToDashboardFromFriends {
            width: 80%;
            margin: 3% auto;
        }

        /* Small Reset Button for Game Room */
        #resetBoard {
            width: 80px;
            padding: 2%;
            font-size: clamp(0.7rem, 2vw, 0.8rem);
            background: linear-gradient(45deg, #ff0057, #00ff57);
            box-shadow: 0 0 15px #5700ff;
            margin: 3% auto;
        }

        #resetBoard:hover {
            box-shadow: 0 0 25px #ff0057;
            transform: scale(1.1);
        }

        @media (max-width: 600px) {
            .container {
                padding: 8%;
                width: 95%;
            }
            h2 {
                font-size: clamp(1.5rem, 5vw, 1.8rem);
            }
            button, input {
                padding: 4%;
                font-size: clamp(0.8rem, 2.5vw, 0.9rem);
            }
            .game-board {
                width: 95%;
                grid-template-columns: repeat(3, 31%);
                gap: 1%;
            }
            .cell {
                font-size: clamp(1.5rem, 6vw, 2rem);
            }
            .circle-btn, #playButton, #winButton, #friendsBtn {
                width: clamp(40px, 8vw, 50px);
                height: clamp(40px, 8vw, 50px);
                font-size: clamp(0.8rem, 2.5vw, 1rem);
            }
            .balance-box {
                width: clamp(80px, 20vw, 120px);
                padding: 3%;
                font-size: clamp(0.8rem, 3vw, 1rem);
            }
            #profileBtn {
                top: 3%;
                right: 3%;
            }
            #walletBtn {
                top: 3%;
                left: 3%;
            }
            .balance-box {
                top: 15%;
            }
            #playButton {
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
            }
            #winButton {
                bottom: 3%;
                left: 3%;
            }
            #friendsBtn {
                bottom: 3%;
                left: 28%;
            }
            #tournamentsBtn {
                bottom: 3%;
                right: 28%;
            }
            #tasksBtn {
                bottom: 3%;
                right: 3%;
            }
            .dashboard-center {
                margin: 25% auto 15% auto;
            }
            .profile-pic-circle {
                width: clamp(60px, 15vw, 80px);
                height: clamp(60px, 15vw, 80px);
            }
            .username-display {
                font-size: clamp(0.8rem, 3vw, 1rem);
            }
            .edit-icon {
                font-size: clamp(0.7rem, 2vw, 0.9rem);
            }
            .profile-content {
                margin-top: 5%;
            }
            .history-box p, .friend-box p, .result-box p, .request-box p {
                font-size: clamp(0.8rem, 2vw, 0.9rem);
                margin-bottom: 3%;
            }
            .history-container, .friends-list, #searchResults, #friendRequests {
                gap: 10px;
            }
            .stats-summary {
                font-size: clamp(0.8rem, 3vw, 1rem);
            }
            .tabs {
                flex-direction: column;
                gap: 5px;
            }
            .tab-btn {
                width: 100%;
                padding: 4%;
            }
            #resetBoard {
                width: 60px;
                font-size: clamp(0.6rem, 1.8vw, 0.7rem);
            }
        }
    </style>
</head>
<body>
    <!-- Auth Container -->
    <div class="container" id="authContainer">
        <h2 id="formTitle">Sign Up</h2>
        <div class="input-box">
            <input type="email" id="email" placeholder="Email" required>
        </div>
        <div class="input-box">
            <input type="password" id="password" placeholder="Password" required>
        </div>
        <div class="input-box">
            <input type="text" id="username" placeholder="Username" required>
        </div>
        <button id="authButton">Sign Up</button>
        <span class="toggle-text" id="toggleAuth">Already have an account? Login</span>
    </div>

    <!-- Dashboard -->
    <div class="container dashboard" id="dashboard">
        <div class="balance-box">₹0</div>
        <button class="circle-btn" id="profileBtn">Pro</button>
        <button class="circle-btn" id="walletBtn">W</button>
        <button class="circle-btn friends-btn" id="friendsBtn">Fr</button>
        <button class="circle-btn" id="tournamentsBtn">To</button>
        <button class="circle-btn" id="tasksBtn">T</button>
        <button class="circle-btn play-btn" id="playButton">Play</button>
        <button class="circle-btn win-btn" id="winButton">Win</button>
        <div class="dashboard-center">
            <h2>Welcome, <span id="userDisplay"></span></h2>
            <div id="verifyEmailPrompt" style="display: none;">
                <p style="color: #ff5733; text-shadow: 0 0 5px #ff5733; margin-bottom: 5%;">
                    Please verify your email to play. Check your inbox!
                </p>
                <button id="resendVerification">Resend Verification Email</button>
            </div>
            <button id="logoutButton">Logout</button>
        </div>
    </div>

    <!-- Profile Page -->
    <div class="container profile-page" id="profilePage">
        <h2>Profile</h2>
        <div class="profile-content">
            <div id="profilePicCircle" class="profile-pic-circle"></div>
            <input type="file" id="profilePicInput" accept="image/png,image/jpeg">
            <div class="username-container">
                <span id="usernameDisplay" class="username-display" contenteditable="false">Set Username</span>
                <span class="edit-icon">✏</span>
            </div>
        </div>
        <button class="game-history-btn" id="gameHistoryBtn">Game History</button>
        <button id="backToDashboardFromProfile">Go to Dashboard</button>
    </div>

    <!-- Game History Page -->
    <div class="container game-history-page" id="gameHistoryPage">
        <h2>Game History</h2>
        <div class="history-container" id="historyContainer"></div>
        <div class="stats-summary" id="statsSummary"></div>
        <button id="backToProfile">Go to Profile</button>
    </div>

    <!-- Friends Page -->
    <div class="container friends-page" id="friendsPage">
        <h2>Friends</h2>
        <div class="tabs">
            <button class="tab-btn active" data-tab="friends">Friends</button>
            <button class="tab-btn" data-tab="add-friend">Add Friend</button>
            <button class="tab-btn" data-tab="requests">Friend Requests</button>
        </div>
        <div class="tab-content active" id="friendsTab">
            <div class="friends-list" id="friendsList"></div>
        </div>
        <div class="tab-content" id="addFriendTab">
            <div class="input-box">
                <input type="text" id="friendSearch" placeholder="Enter username">
            </div>
            <button id="searchFriend">Search</button>
            <div id="searchResults"></div>
        </div>
        <div class="tab-content" id="requestsTab">
            <div id="friendRequests"></div>
        </div>
        <button id="backToDashboardFromFriends">Go to Dashboard</button>
    </div>

    <!-- Game Page -->
    <div class="container game-page" id="gamePage">
        <h2>Play Tic-Tac-Toe</h2>
        <button id="playRandom">Play with Random Player</button>
        <button id="backToDashboard">Back to Dashboard</button>
    </div>

    <!-- Game Room -->
    <div class="container game-room" id="gameRoom">
        <h2>Tic-Tac-Toe</h2>
        <p class="room-id" id="roomIdDisplay"></p>
        <p class="status" id="gameStatus">Waiting for opponent...</p>
        <p id="playersDisplay"></p>
        <div class="game-board" id="gameBoard">
            <div class="cell" data-index="0"></div>
            <div class="cell" data-index="1"></div>
            <div class="cell" data-index="2"></div>
            <div class="cell" data-index="3"></div>
            <div class="cell" data-index="4"></div>
            <div class="cell" data-index="5"></div>
            <div class="cell" data-index="6"></div>
            <div class="cell" data-index="7"></div>
            <div class="cell" data-index="8"></div>
        </div>
        <button id="leaveRoom">Leave Room</button>
        <button id="resetBoard">Reset</button>
    </div>

    <!-- Waiting Area -->
    <div class="container waiting-area" id="waitingArea">
        <h2>Matchmaking</h2>
        <p>Searching for opponent...</p>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-app.js";
        import { 
            getAuth, 
            createUserWithEmailAndPassword, 
            signInWithEmailAndPassword, 
            onAuthStateChanged, 
            signOut, 
            sendEmailVerification 
        } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-auth.js";
        import { 
            getFirestore, 
            doc, 
            setDoc, 
            getDoc, 
            onSnapshot, 
            updateDoc, 
            deleteDoc, 
            collection, 
            addDoc, 
            query, 
            where, 
            getDocs, 
            serverTimestamp,
            runTransaction 
        } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-firestore.js";
        import { 
            getStorage, 
            ref, 
            uploadBytes, 
            getDownloadURL 
        } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-storage.js";

        // Firebase Config
        const firebaseConfig = {
            apiKey: "AIzaSyAol2UzQWdFPyTeWhlfK7HTXxMpsuXnSFk",
            authDomain: "final-78170.firebaseapp.com",
            projectId: "final-78170",
            storageBucket: "final-78170.firebasestorage.app",
            messagingSenderId: "374288155367",
            appId: "1:374288155367:web:94a49f3b204dfa2efc5842",
            measurementId: "G-9GM80JWP3C"
        };

        let auth, db, storage;
        try {
            const app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
            storage = getStorage(app);
        } catch (error) {
            showMessage('Failed to initialize Firebase: ' + error.message, 'error');
        }

        // DOM Elements
        const authContainer = document.getElementById('authContainer');
        const dashboard = document.getElementById('dashboard');
        const profilePage = document.getElementById('profilePage');
        const gameHistoryPage = document.getElementById('gameHistoryPage');
        const friendsPage = document.getElementById('friendsPage');
        const gamePage = document.getElementById('gamePage');
        const gameRoom = document.getElementById('gameRoom');
        const waitingArea = document.getElementById('waitingArea');
        const formTitle = document.getElementById('formTitle');
        const authButton = document.getElementById('authButton');
        const toggleAuth = document.getElementById('toggleAuth');
        const emailInput = document.getElementById('email');
        const passwordInput = document.getElementById('password');
        const usernameInput = document.getElementById('username');
        const userDisplay = document.getElementById('userDisplay');
        const usernameDisplay = document.getElementById('usernameDisplay');
        const profilePicCircle = document.getElementById('profilePicCircle');
        const profilePicInput = document.getElementById('profilePicInput');
        const gameHistoryBtn = document.getElementById('gameHistoryBtn');
        const backToDashboardFromProfile = document.getElementById('backToDashboardFromProfile');
        const historyContainer = document.getElementById('historyContainer');
        const statsSummary = document.getElementById('statsSummary');
        const backToProfile = document.getElementById('backToProfile');
        const playButton = document.getElementById('playButton');
        const winButton = document.getElementById('winButton');
        const friendsBtn = document.getElementById('friendsBtn');
        const logoutButton = document.getElementById('logoutButton');
        const playRandom = document.getElementById('playRandom');
        const backToDashboard = document.getElementById('backToDashboard');
        const roomIdDisplay = document.getElementById('roomIdDisplay');
        const gameStatus = document.getElementById('gameStatus');
        const gameBoard = document.getElementById('gameBoard');
        const leaveRoom = document.getElementById('leaveRoom');
        const resetBoard = document.getElementById('resetBoard');
        const playersDisplay = document.getElementById('playersDisplay');
        const verifyEmailPrompt = document.getElementById('verifyEmailPrompt');
        const resendVerification = document.getElementById('resendVerification');
        const profileBtn = document.getElementById('profileBtn');
        const friendsTab = document.getElementById('friendsTab');
        const addFriendTab = document.getElementById('addFriendTab');
        const requestsTab = document.getElementById('requestsTab');
        const friendsList = document.getElementById('friendsList');
        const friendSearch = document.getElementById('friendSearch');
        const searchFriend = document.getElementById('searchFriend');
        const searchResults = document.getElementById('searchResults');
        const friendRequests = document.getElementById('friendRequests');
        const backToDashboardFromFriends = document.getElementById('backToDashboardFromFriends');

        // Initialize Containers
        function initializeContainers() {
            const containers = [authContainer, dashboard, profilePage, gameHistoryPage, friendsPage, gamePage, gameRoom, waitingArea];
            containers.forEach(c => c && (c.style.display = 'none'));
            authContainer.style.display = 'block';
        }
        initializeContainers();

        let isSignUp = true;
        let currentRoomId = null;
        let currentPlayer = null;
        let opponentUsername = null;
        let unsubscribeRoom = null;
        let lastSaveTime = 0;

        // Show Message (Only for essential messages)
        function showMessage(message, type) {
            const msgDiv = document.createElement('div');
            msgDiv.className = `message ${type}`;
            msgDiv.textContent = message;
            document.body.appendChild(msgDiv);
            msgDiv.style.opacity = '1';
            setTimeout(() => {
                msgDiv.style.opacity = '0';
                setTimeout(() => msgDiv.remove(), 300);
            }, 3000);
        }

        // Show/Hide Containers
        function showContainer(container) {
            const containers = [authContainer, dashboard, profilePage, gameHistoryPage, friendsPage, gamePage, gameRoom, waitingArea];
            containers.forEach(c => c && (c.style.display = 'none'));
            container.style.display = 'block';
            if (container === gamePage) {
                playRandom.disabled = false;
            }
        }

        // Update Profile UI
        function updateProfileUI(username, avatarUrl) {
            if (!profileBtn || !profilePicCircle) {
                showMessage('Profile elements not found', 'error');
                return;
            }
            if (avatarUrl) {
                profileBtn.style.backgroundImage = `url(${avatarUrl})`;
                profilePicCircle.style.backgroundImage = `url(${avatarUrl})`;
            } else {
                const firstLetter = username.charAt(0).toUpperCase() || 'P';
                const canvas = document.createElement('canvas');
                const size = 100;
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                ctx.beginPath();
                ctx.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2);
                ctx.fillStyle = '#ff0057';
                ctx.fill();
                ctx.font = 'bold 60px Impact';
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(firstLetter, size / 2, size / 2);
                const canvasUrl = canvas.toDataURL();
                profileBtn.style.backgroundImage = `url(${canvasUrl})`;
                profilePicCircle.style.backgroundImage = `url(${canvasUrl})`;
            }
            profileBtn.style.color = 'transparent';
            profilePicCircle.style.color = 'transparent';
            profileBtn.style.backgroundSize = 'cover';
            profileBtn.style.border = '3px solid #ff0057';
            profilePicCircle.style.backgroundSize = 'cover';
            profilePicCircle.style.border = '3px solid #ff0057';
            userDisplay.textContent = username;
            usernameDisplay.textContent = username;
        }

        // Update Balance UI
        async function updateBalanceUI() {
            const user = auth.currentUser;
            if (user) {
                try {
                    const userDoc = await getDoc(doc(db, 'users', user.uid));
                    const coins = userDoc.exists() ? userDoc.data().coins || 0 : 0;
                    document.querySelector('.balance-box').textContent = `₹${coins}`;
                } catch (error) {
                    showMessage(`Error updating balance: ${error.message}`, 'error');
                }
            }
        }

        // Check Username Availability
        async function checkUsernameAvailability(username) {
            if (!username || typeof username !== 'string' || username.trim() === '') {
                return { available: false, message: 'Username cannot be empty' };
            }
            const normalizedUsername = username.toLowerCase().trim();
            if (!/^[a-zA-Z0-9_]{3,20}$/.test(normalizedUsername)) {
                return { available: false, message: 'Username must be 3-20 characters, letters, numbers, or underscores only' };
            }
            try {
                const usernameDoc = await getDoc(doc(db, 'usernames', normalizedUsername));
                if (usernameDoc.exists()) {
                    return { available: false, message: 'Username is already taken' };
                }
                return { available: true };
            } catch (error) {
                return { available: false, message: `Error checking username: ${error.message}` };
            }
        }

        // Save Username
        async function saveUsername(userId, username) {
            const normalizedUsername = username.toLowerCase().trim();
            const check = await checkUsernameAvailability(username);
            if (!check.available) {
                throw new Error(check.message);
            }
            try {
                const usernameRef = doc(db, 'usernames', normalizedUsername);
                await setDoc(usernameRef, {
                    userId,
                    createdAt: serverTimestamp()
                });
            } catch (error) {
                throw new Error(`Error saving username: ${error.message}`);
            }
        }

        // Delete Username
        async function deleteUsername(userId, username) {
            const normalizedUsername = username.toLowerCase().trim();
            const usernameRef = doc(db, 'usernames', normalizedUsername);
            const usernameDoc = await getDoc(usernameRef);
            if (usernameDoc.exists() && usernameDoc.data().userId === userId) {
                await deleteDoc(usernameRef);
            }
        }

        // Save Profile
        async function saveProfile(username, oldUsername = null, isSignUp = false) {
            const now = Date.now();
            if (now - lastSaveTime < 500) {
                showMessage('Please wait before saving again', 'error');
                return;
            }
            lastSaveTime = now;
            const user = auth.currentUser;
            if (!user) {
                showMessage('Please log in first', 'error');
                return;
            }
            if (!isSignUp && !user.emailVerified) {
                showMessage('Please verify your email first', 'error');
                return;
            }
            try {
                const userDocRef = doc(db, 'users', user.uid);
                const userData = {
                    username,
                    avatarUrl: null
                };
                await saveUsername(user.uid, username);
                if (oldUsername && oldUsername !== username) {
                    await deleteUsername(user.uid, oldUsername);
                }
                await setDoc(userDocRef, {
                    ...userData,
                    stats: { wins: 0, losses: 0, ties: 0 },
                    coins: 100
                }, { merge: true });
                updateProfileUI(username, null);
                await updateBalanceUI();
            } catch (error) {
                showMessage(`Error saving profile: ${error.message}`, 'error');
                throw error;
            }
        }

        // Profile Picture Click
        profilePicCircle?.addEventListener('click', () => {
            profilePicInput?.click();
        });

        // Profile Picture Change
        profilePicInput?.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const user = auth.currentUser;
            if (!user) {
                showMessage('Please log in first', 'error');
                return;
            }
            try {
                const storageRef = ref(storage, `profile_pics/${user.uid}`);
                await uploadBytes(storageRef, file);
                const avatarUrl = await getDownloadURL(storageRef);
                await setDoc(doc(db, 'users', user.uid), { avatarUrl }, { merge: true });
                const userDoc = await getDoc(doc(db, 'users', user.uid));
                updateProfileUI(userDoc.data().username || 'Player', avatarUrl);
            } catch (error) {
                showMessage(`Error uploading profile picture: ${error.message}`, 'error');
            }
            profilePicInput.value = '';
        });

        // Username Editing
        usernameDisplay?.addEventListener('click', () => {
            usernameDisplay.contentEditable = 'true';
            usernameDisplay.focus();
        });

        usernameDisplay?.addEventListener('blur', async () => {
            usernameDisplay.contentEditable = 'false';
            const newUsername = usernameDisplay.textContent.trim();
            if (!newUsername) {
                showMessage('Please enter a username', 'error');
                const userDoc = await getDoc(doc(db, 'users', auth.currentUser?.uid));
                usernameDisplay.textContent = userDoc.exists() && userDoc.data().username ? userDoc.data().username : 'Player';
                return;
            }
            const userDoc = await getDoc(doc(db, 'users', auth.currentUser.uid));
            const oldUsername = userDoc.exists() ? userDoc.data().username : null;
            await saveProfile(newUsername, oldUsername);
        });

        usernameDisplay?.addEventListener('keydown', async (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                usernameDisplay.blur();
            }
        });

        // Profile Button
        profileBtn?.addEventListener('click', async () => {
            const user = auth.currentUser;
            if (!user) {
                showMessage('Please log in first', 'error');
                showContainer(authContainer);
                return;
            }
            try {
                const userDoc = await getDoc(doc(db, 'users', user.uid));
                const username = userDoc.exists() && userDoc.data().username ? userDoc.data().username : 'Player';
                const avatarUrl = userDoc.exists() ? userDoc.data().avatarUrl : null;
                usernameDisplay.textContent = username;
                updateProfileUI(username, avatarUrl);
                showContainer(profilePage);
            } catch (error) {
                showMessage(`Error loading profile: ${error.message}`, 'error');
            }
        });

        // Back to Dashboard from Profile
        backToDashboardFromProfile?.addEventListener('click', () => {
            showContainer(dashboard);
        });

        // Game History Button
        gameHistoryBtn?.addEventListener('click', async () => {
            const user = auth.currentUser;
            if (!user) {
                showMessage('Please log in first', 'error');
                showContainer(authContainer);
                return;
            }
            try {
                const userDoc = await getDoc(doc(db, 'users', user.uid));
                const stats = userDoc.exists() && userDoc.data().stats ? userDoc.data().stats : { wins: 0, losses: 0, ties: 0 };
                const historyQuery = query(collection(db, `users/${user.uid}/gameHistory`));
                const historyDocs = await getDocs(historyQuery);
                historyContainer.innerHTML = '';
                historyDocs.forEach(doc => {
                    const game = doc.data();
                    const date = game.timestamp?.toDate ? game.timestamp.toDate() : new Date();
                    const formattedDate = date.toLocaleString('en-US', {
                        month: 'long',
                        day: '2-digit',
                        year: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit',
                        hour12: false
                    });
                    const box = document.createElement('div');
                    box.className = `history-box ${game.result === 'win' ? 'win' : 'loss-tie'}`;
                    box.innerHTML = `
                        <p>Opponent: ${game.opponentUsername || 'Unknown'}</p>
                        <p>Result: ${game.result.charAt(0).toUpperCase() + game.result.slice(1)}</p>
                        <p>Time: ${formattedDate}</p>
                    `;
                    historyContainer.appendChild(box);
                });
                statsSummary.textContent = `Total Matches: Wins ${stats.wins}, Losses ${stats.losses}, Ties ${stats.ties}`;
                showContainer(gameHistoryPage);
            } catch (error) {
                showMessage(`Error loading game history: ${error.message}`, 'error');
            }
        });

        // Back to Profile
        backToProfile?.addEventListener('click', () => {
            showContainer(profilePage);
        });

        // Friends Button
        friendsBtn?.addEventListener('click', async () => {
            const user = auth.currentUser;
            if (!user) {
                showMessage('Please log in first', 'error');
                showContainer(authContainer);
                return;
            }
            try {
                showContainer(friendsPage);
                loadFriendsTab();
            } catch (error) {
                showMessage(`Error loading friends: ${error.message}`, 'error');
            }
        });

        // Tab Switching
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                btn.classList.add('active');
                document.getElementById(`${btn.dataset.tab}Tab`).classList.add('active');
                if (btn.dataset.tab === 'friends') loadFriendsTab();
                else if (btn.dataset.tab === 'add-friend') loadAddFriendTab();
                else if (btn.dataset.tab === 'requests') loadRequestsTab();
            });
        });

        // Load Friends Tab
        async function loadFriendsTab() {
            const user = auth.currentUser;
            if (!user) {
                showMessage('Please log in first', 'error');
                return;
            }
            let unsubscribe = null;
            try {
                friendsList.innerHTML = '';
                const friendsQuery = query(collection(db, `users/${user.uid}/friends`));
                unsubscribe = onSnapshot(friendsQuery, (snapshot) => {
                    friendsList.innerHTML = '';
                    if (snapshot.empty) {
                        friendsList.innerHTML = '<p style="color: #ff0057; text-shadow: 0 0 10px #ff0057;">No friends yet.</p>';
                        return;
                    }
                    snapshot.forEach(doc => {
                        const friend = doc.data();
                        const friendBox = document.createElement('div');
                        friendBox.className = 'friend-box';
                        friendBox.innerHTML = `
                            <p>Username: ${friend.username}</p>
                            <button class="action-btn" data-friend-id="${doc.id}" data-username="${friend.username}">Remove Friend</button>
                        `;
                        friendsList.appendChild(friendBox);
                    });

                    friendsList.querySelectorAll('.action-btn').forEach(btn => {
                        btn.addEventListener('click', async () => {
                            try {
                                const friendId = btn.dataset.friendId;
                                const friendUsername = btn.dataset.username;
                                const friendDoc = await getDoc(doc(db, 'usernames', friendUsername.toLowerCase()));
                                if (friendDoc.exists()) {
                                    const friendUserId = friendDoc.data().userId;
                                    await deleteDoc(doc(db, `users/${user.uid}/friends`, friendId));
                                    await deleteDoc(doc(db, `users/${friendUserId}/friends`, user.uid));
                                }
                            } catch (error) {
                                showMessage(`Error removing friend: ${error.message}`, 'error');
                            }
                        });
                    });
                });
            } catch (error) {
                showMessage(`Error loading friends: ${error.message}`, 'error');
            }
            friendsPage.addEventListener('unload', () => unsubscribe && unsubscribe(), { once: true });
        }

        // Load Add Friend Tab
        async function loadAddFriendTab() {
            searchResults.innerHTML = '';
            friendSearch.value = '';
        }

        // Search Friend
        searchFriend?.addEventListener('click', async () => {
            const searchTerm = friendSearch.value.trim();
            if (!searchTerm) {
                showMessage('Please enter a username', 'error');
                return;
            }
            try {
                const usernameDoc = await getDoc(doc(db, 'usernames', searchTerm.toLowerCase()));
                if (!usernameDoc.exists()) {
                    searchResults.innerHTML = '<p style="color: #ff0057; text-shadow: 0 0 10px #ff0057;">User not found.</p>';
                    return;
                }
                const user = auth.currentUser;
                const foundUserId = usernameDoc.data().userId;
                if (foundUserId === user.uid) {
                    searchResults.innerHTML = '<p style="color: #ff0057; text-shadow: 0 0 10px #ff0057;">You cannot add yourself.</p>';
                    return;
                }
                const friendDoc = await getDoc(doc(db, `users/${user.uid}/friends`, foundUserId));
                if (friendDoc.exists()) {
                    searchResults.innerHTML = '<p style="color: #ff0057; text-shadow: 0 0 10px #ff0057;">Already friends.</p>';
                    return;
                }
                const outgoingRequestQuery = query(
                    collection(db, `users/${user.uid}/friendRequests`),
                    where('toUserId', '==', foundUserId),
                    where('status', '==', 'pending')
                );
                const incomingRequestQuery = query(
                    collection(db, `users/${user.uid}/friendRequests`),
                    where('fromUserId', '==', foundUserId),
                    where('status', '==', 'pending')
                );
                const [outgoingDocs, incomingDocs] = await Promise.all([
                    getDocs(outgoingRequestQuery),
                    getDocs(incomingRequestQuery)
                ]);
                if (!outgoingDocs.empty) {
                    searchResults.innerHTML = '<p style="color: #ff0057; text-shadow: 0 0 10px #ff0057;">Request already sent.</p>';
                    return;
                }
                if (!incomingDocs.empty) {
                    searchResults.innerHTML = '<p style="color: #ff0057; text-shadow: 0 0 10px #ff0057;">Check pending requests.</p>';
                    return;
                }
                searchResults.innerHTML = '';
                const resultBox = document.createElement('div');
                resultBox.className = 'result-box';
                resultBox.innerHTML = `
                    <p>Username: ${searchTerm}</p>
                    <button class="action-btn" data-user-id="${foundUserId}" data-username="${searchTerm}">Send Friend Request</button>
                `;
                searchResults.appendChild(resultBox);

                resultBox.querySelector('.action-btn').addEventListener('click', async () => {
                    try {
                        const userDoc = await getDoc(doc(db, 'users', user.uid));
                        const fromUsername = userDoc.data().username;
                        const requestData = {
                            fromUserId: user.uid,
                            fromUsername,
                            toUserId: foundUserId,
                            toUsername: searchTerm,
                            status: 'pending',
                            createdAt: serverTimestamp()
                        };
                        const requestRef = await addDoc(collection(db, `users/${foundUserId}/friendRequests`), requestData);
                        await setDoc(doc(db, `users/${user.uid}/friendRequests`, requestRef.id), requestData);
                        searchResults.innerHTML = '';
                        friendSearch.value = '';
                    } catch (error) {
                        showMessage(`Error sending request: ${error.message}`, 'error');
                    }
                });
            } catch (error) {
                showMessage(`Error searching user: ${error.message}`, 'error');
            }
        });

        // Load Friend Requests Tab
        async function loadRequestsTab() {
            const user = auth.currentUser;
            if (!user) {
                showMessage('Please log in first', 'error');
                return;
            }
            try {
                friendRequests.innerHTML = '';
                const requestsQuery = query(
                    collection(db, `users/${user.uid}/friendRequests`),
                    where('toUserId', '==', user.uid),
                    where('status', '==', 'pending')
                );
                const requestsDocs = await getDocs(requestsQuery);
                if (requestsDocs.empty) {
                    friendRequests.innerHTML = '<p style="color: #ff0057; text-shadow: 0 0 10px #ff0057;">No pending requests.</p>';
                    return;
                }
                requestsDocs.forEach(doc => {
                    const request = doc.data();
                    const requestBox = document.createElement('div');
                    requestBox.className = 'request-box';
                    requestBox.innerHTML = `
                        <p>From: ${request.fromUsername}</p>
                        <button class="action-btn accept-btn" data-request-id="${doc.id}" data-from-id="${request.fromUserId}" data-from-username="${request.fromUsername}">Accept</button>
                        <button class="action-btn reject-btn" data-request-id="${doc.id}" data-from-id="${request.fromUserId}" data-from-username="${request.fromUsername}">Reject</button>
                    `;
                    friendRequests.appendChild(requestBox);
                });

                friendRequests.querySelectorAll('.accept-btn').forEach(btn => {
                    btn.addEventListener('click', async () => {
                        try {
                            const requestId = btn.dataset.requestId;
                            const fromId = btn.dataset.fromId;
                            const fromUsername = btn.dataset.fromUsername;
                            const userDoc = await getDoc(doc(db, 'users', user.uid));
                            const toUsername = userDoc.data().username;
                            await setDoc(doc(db, `users/${user.uid}/friends`, fromId), {
                                username: fromUsername,
                                addedAt: serverTimestamp()
                            });
                            await setDoc(doc(db, `users/${fromId}/friends`, user.uid), {
                                username: toUsername,
                                addedAt: serverTimestamp()
                            });
                            await updateDoc(doc(db, `users/${user.uid}/friendRequests`, requestId), { status: 'accepted' });
                            await updateDoc(doc(db, `users/${fromId}/friendRequests`, requestId), { status: 'accepted' });
                            loadRequestsTab();
                        } catch (error) {
                            showMessage(`Error accepting request: ${error.message}`, 'error');
                        }
                    });
                });

                friendRequests.querySelectorAll('.reject-btn').forEach(btn => {
                    btn.addEventListener('click', async () => {
                        try {
                            const requestId = btn.dataset.requestId;
                            const fromId = btn.dataset.fromId;
                            const fromUsername = btn.dataset.fromUsername;
                            await updateDoc(doc(db, `users/${user.uid}/friendRequests`, requestId), { status: 'rejected' });
                            await updateDoc(doc(db, `users/${fromId}/friendRequests`, requestId), { status: 'rejected' });
                            loadRequestsTab();
                        } catch (error) {
                            showMessage(`Error rejecting request: ${error.message}`, 'error');
                        }
                    });
                });
            } catch (error) {
                showMessage(`Error loading requests: ${error.message}`, 'error');
            }
        }

        // Back to Dashboard from Friends
        backToDashboardFromFriends?.addEventListener('click', () => {
            showContainer(dashboard);
        });

        // Toggle Auth Mode
        toggleAuth.addEventListener('click', () => {
            isSignUp = !isSignUp;
            formTitle.textContent = isSignUp ? 'Sign Up' : 'Login';
            authButton.textContent = isSignUp ? 'Sign Up' : 'Login';
            toggleAuth.textContent = isSignUp ? 'Already have an account? Login' : 'Need an account? Sign Up';
            usernameInput.style.display = isSignUp ? 'block' : 'none';
            usernameInput.parentElement.style.display = isSignUp ? 'block' : 'none';
        });

        // Authentication Handler
        authButton.addEventListener('click', async () => {
            const email = emailInput?.value;
            const password = passwordInput?.value;
            const username = isSignUp ? usernameInput?.value : null;
            if (!email || !password) {
                showMessage('Please enter email and password', 'error');
                return;
            }
            if (isSignUp && !username) {
                showMessage('Please enter a username', 'error');
                return;
            }
            try {
                if (isSignUp) {
                    const check = await checkUsernameAvailability(username);
                    if (!check.available) {
                        showMessage(check.message, 'error');
                        return;
                    }
                    const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                    try {
                        await saveProfile(username, null, true);
                        await sendEmailVerification(userCredential.user);
                    } catch (error) {
                        await userCredential.user.delete();
                        showMessage(`Sign-up failed: ${error.message}`, 'error');
                    }
                } else {
                    await signInWithEmailAndPassword(auth, email, password);
                }
                emailInput.value = '';
                passwordInput.value = '';
                usernameInput.value = '';
            } catch (error) {
                showMessage(`Error: ${error.message}`, 'error');
            }
        });

        // Resend Verification Email
        resendVerification?.addEventListener('click', async () => {
            const user = auth.currentUser;
            if (user && !user.emailVerified) {
                try {
                    await sendEmailVerification(user);
                } catch (error) {
                    showMessage(`Error: ${error.message}`, 'error');
                }
            }
        });

        // Play Button
        playButton.addEventListener('click', async () => {
            const user = auth.currentUser;
            if (!user) {
                showMessage('Please log in first', 'error');
                showContainer(authContainer);
                return;
            }
            if (!user.emailVerified) {
                showMessage('Please verify your email first', 'error');
                return;
            }
            try {
                const userDoc = await getDoc(doc(db, 'users', user.uid));
                if (userDoc.exists() && userDoc.data().username) {
                    showContainer(gamePage);
                } else {
                    showMessage('Please set a username first', 'error');
                    showContainer(profilePage);
                }
            } catch (error) {
                showMessage(`Error: ${error.message}`, 'error');
            }
        });

        // Back to Dashboard
        backToDashboard.addEventListener('click', () => {
            if (!auth.currentUser) {
                showMessage('Please log in first', 'error');
                showContainer(authContainer);
                return;
            }
            showContainer(dashboard);
        });

        // Play with Random Player
        playRandom.addEventListener('click', async () => {
            playRandom.disabled = true;
            const user = auth.currentUser;
            if (!user || !user.emailVerified) {
                showMessage('Please verify your email first', 'error');
                showContainer(authContainer);
                playRandom.disabled = false;
                return;
            }
            showContainer(waitingArea);
            let matchmakingId = null;
            let unsubscribeMatch = null;

            const timeout = setTimeout(async () => {
                if (matchmakingId) {
                    await deleteDoc(doc(db, 'matchmaking', matchmakingId)).catch(err => showMessage(`Cleanup error: ${err.message}`, 'error'));
                }
                showMessage('No opponent found. Try again.', 'error');
                showContainer(gamePage);
                playRandom.disabled = false;
                if (unsubscribeMatch) unsubscribeMatch();
            }, 30000);

            try {
                const userDoc = await getDoc(doc(db, 'users', user.uid));
                const username = userDoc.data()?.username || 'Player';

                // Clean up existing matchmaking entries
                const userEntries = await getDocs(query(collection(db, 'matchmaking'), where('userId', '==', user.uid)));
                for (const entry of userEntries.docs) {
                    await deleteDoc(doc(db, 'matchmaking', entry.id)).catch(err => showMessage(`Cleanup error: ${err.message}`, 'error'));
                }

                // Create matchmaking entry
                const matchmakingRef = doc(collection(db, 'matchmaking'));
                matchmakingId = matchmakingRef.id;
                await setDoc(matchmakingRef, {
                    userId: user.uid,
                    username,
                    status: 'waiting',
                    timestamp: serverTimestamp()
                });

                // Listen for matchmaking updates with retry
                let snapshotRetries = 0;
                const maxSnapshotRetries = 3;
                unsubscribeMatch = onSnapshot(matchmakingRef, async (snapshot) => {
                    try {
                        if (!snapshot.exists()) {
                            showMessage('Matchmaking canceled.', 'error');
                            showContainer(gamePage);
                            playRandom.disabled = false;
                            clearTimeout(timeout);
                            if (unsubscribeMatch) unsubscribeMatch();
                            return;
                        }
                        const data = snapshot.data();
                        if (data.status === 'paired' && data.roomId) {
                            currentRoomId = data.roomId;
                            currentPlayer = data.playerSymbol;
                            opponentUsername = data.opponentUsername;
                            await deleteDoc(matchmakingRef).catch(err => showMessage(`Cleanup error: ${err.message}`, 'error'));
                            if (unsubscribeMatch) unsubscribeMatch();
                            clearTimeout(timeout);
                            showContainer(gameRoom);
                            roomIdDisplay.textContent = `Room ID: ${currentRoomId}`;
                            listenToRoom(currentRoomId, username);
                            showMessage('Room joined!', 'success');
                        }
                    } catch (error) {
                        snapshotRetries++;
                        if (snapshotRetries >= maxSnapshotRetries) {
                            showMessage(`Matchmaking listener error: ${error.message}`, 'error');
                            cleanupMatchmaking();
                        }
                    }
                }, (error) => {
                    showMessage(`Matchmaking listener error: ${error.message}`, 'error');
                    cleanupMatchmaking();
                });

                // Check for available opponents with retry
                const findOpponent = async (retryCount = 0) => {
                    try {
                        const q = query(collection(db, 'matchmaking'), where('status', '==', 'waiting'));
                        const snapshot = await getDocs(q);
                        const validOpponents = snapshot.docs.filter(doc => doc.data().userId !== user.uid);
                        if (validOpponents.length > 0) {
                            const opponentDoc = validOpponents[0];
                            const opponentData = opponentDoc.data();

                            // Create game room
                            const roomRef = doc(collection(db, 'rooms'));
                            const roomData = {
                                player1: user.uid,
                                player1Username: username,
                                player2: opponentData.userId,
                                player2Username: opponentData.username,
                                board: ['', '', '', '', '', '', '', '', ''],
                                currentTurn: 'X',
                                status: 'active',
                                createdAt: serverTimestamp()
                            };
                            await setDoc(roomRef, roomData);

                            // Update matchmaking entries
                            await updateDoc(doc(db, 'matchmaking', opponentDoc.id), {
                                status: 'paired',
                                roomId: roomRef.id,
                                playerSymbol: 'X',
                                opponentUsername: username
                            });
                            await updateDoc(matchmakingRef, {
                                status: 'paired',
                                roomId: roomRef.id,
                                playerSymbol: 'O',
                                opponentUsername: opponentData.username
                            });
                        } else if (retryCount < 10) {
                            setTimeout(() => findOpponent(retryCount + 1), 1500);
                        }
                    } catch (error) {
                        showMessage(`Matchmaking error: ${error.message}`, 'error');
                        cleanupMatchmaking();
                    }
                };
                await findOpponent();

                function cleanupMatchmaking() {
                    if (matchmakingId) {
                        deleteDoc(doc(db, 'matchmaking', matchmakingId)).catch(err => showMessage(`Cleanup error: ${err.message}`, 'error'));
                    }
                    clearTimeout(timeout);
                    showContainer(gamePage);
                    playRandom.disabled = false;
                    if (unsubscribeMatch) unsubscribeMatch();
                }
            } catch (error) {
                showMessage(`Matchmaking error: ${error.message}`, 'error');
                cleanupMatchmaking();
            }
        });

        // Listen to Game Room
        function listenToRoom(roomId, username) {
            const roomRef = doc(db, 'rooms', roomId);
            let snapshotRetries = 0;
            const maxSnapshotRetries = 3;
            unsubscribeRoom = onSnapshot(roomRef, async snapshot => {
                try {
                    if (!snapshot.exists()) {
                        showMessage('Game room closed.', 'error');
                        cleanupRoom();
                        showContainer(gamePage);
                        return;
                    }
                    const data = snapshot.data();
                    updateGameBoard(data.board);
                    playersDisplay.textContent = `You (${username}) vs ${opponentUsername}`;
                    gameStatus.textContent = data.status === 'active' ? 
                        (data.currentTurn === currentPlayer ? 'Your turn!' : `Waiting for ${opponentUsername}'s turn...`) : 
                        data.status;
                    if (data.status !== 'active') {
                        await handleGameEnd(data.status, username);
                    }
                } catch (error) {
                    snapshotRetries++;
                    if (snapshotRetries >= maxSnapshotRetries) {
                        showMessage(`Game room error: ${error.message}`, 'error');
                        cleanupRoom();
                        showContainer(gamePage);
                    }
                }
            }, error => {
                showMessage(`Game room error: ${error.message}`, 'error');
                cleanupRoom();
                showContainer(gamePage);
            });
        }

        // Update Game Board
        function updateGameBoard(board) {
            const cells = gameBoard.querySelectorAll('.cell');
            cells.forEach((cell, index) => {
                cell.textContent = board[index];
                cell.className = 'cell';
                if (board[index] === 'X') {
                    cell.classList.add('x');
                } else if (board[index] === 'O') {
                    cell.classList.add('o');
                }
            });
        }

        // Handle Game Move
        gameBoard.addEventListener('click', async (e) => {
            const cell = e.target.closest('.cell');
            if (!cell) return;
            const index = cell.dataset.index;
            const user = auth.currentUser;
            if (!user || !currentRoomId || !currentPlayer) {
                showMessage('Game state error.', 'error');
                return;
            }
            try {
                const roomRef = doc(db, 'rooms', currentRoomId);
                const roomDoc = await getDoc(roomRef);
                if (!roomDoc.exists()) {
                    showMessage('Game room closed.', 'error');
                    cleanupRoom();
                    showContainer(gamePage);
                    return;
                }
                const data = roomDoc.data();
                if (data.status !== 'active' || data.currentTurn !== currentPlayer || data.board[index] !== '') {
                    showMessage('Invalid move', 'error');
                    return;
                }
                const newBoard = [...data.board];
                newBoard[index] = currentPlayer;
                const newTurn = currentPlayer === 'X' ? 'O' : 'X';
                const winPatterns = [
                    [0, 1, 2], [3, 4, 5], [6, 7, 8],
                    [0, 3, 6], [1, 4, 7], [2, 5, 8],
                    [0, 4, 8], [2, 4, 6]
                ];
                let status = 'active';
                for (const pattern of winPatterns) {
                    if (pattern.every(i => newBoard[i] === currentPlayer)) {
                        status = `${currentPlayer} wins`;
                        break;
                    }
                }
                if (status === 'active' && !newBoard.includes('')) {
                    status = 'tie';
                }
                await updateDoc(roomRef, {
                    board: newBoard,
                    currentTurn: newTurn,
                    status
                });
            } catch (error) {
                showMessage(`Error making move: ${error.message}`, 'error');
            }
        });

        // Reset Board
        resetBoard.addEventListener('click', async () => {
            if (!currentRoomId) {
                showMessage('No active game room.', 'error');
                return;
            }
            try {
                const roomRef = doc(db, 'rooms', currentRoomId);
                await updateDoc(roomRef, {
                    board: ['', '', '', '', '', '', '', '', ''],
                    currentTurn: 'X',
                    status: 'active'
                });
                updateGameBoard(['', '', '', '', '', '', '', '', '']);
            } catch (error) {
                showMessage(`Error resetting board: ${error.message}`, 'error');
            }
        });

        // Handle Game End
        async function handleGameEnd(status, username) {
            const user = auth.currentUser;
            if (!user) return;
            try {
                const userDocRef = doc(db, 'users', user.uid);
                const userDoc = await getDoc(userDocRef);
                const stats = userDoc.exists() && userDoc.data().stats ? userDoc.data().stats : { wins: 0, losses: 0, ties: 0 };
                let result = 'tie';
                if (status === `${currentPlayer} wins`) {
                    result = 'win';
                    stats.wins += 1;
                    showMessage(`${currentPlayer} won!`, 'success');
                } else if (status.includes('wins') && status !== `${currentPlayer} wins`) {
                    result = 'loss';
                    stats.losses += 1;
                    showMessage(`${opponentUsername} won!`, 'success');
                } else if (status === 'tie') {
                    stats.ties += 1;
                    showMessage('Game ended in a tie!', 'success');
                } else if (status === 'abandoned') {
                    result = 'abandoned';
                    showMessage('Game abandoned.', 'success');
                }
                await setDoc(userDocRef, { stats }, { merge: true });
                await addDoc(collection(db, `users/${user.uid}/gameHistory`), {
                    opponentUsername,
                    result,
                    timestamp: serverTimestamp()
                });
                cleanupRoom();
                showContainer(gamePage);
            } catch (error) {
                showMessage(`Error handling game end: ${error.message}`, 'error');
            }
        }

        // Cleanup Room
        function cleanupRoom() {
            if (unsubscribeRoom) {
                unsubscribeRoom();
                unsubscribeRoom = null;
            }
            if (currentRoomId) {
                const roomRef = doc(db, 'rooms', currentRoomId);
                updateDoc(roomRef, {
                    status: 'abandoned',
                    board: ['', '', '', '', '', '', '', '', '']
                }).catch(err => showMessage(`Error abandoning room: ${err.message}`, 'error'));
            }
            currentRoomId = null;
            currentPlayer = null;
            opponentUsername = null;
        }

        // Leave Room
        leaveRoom.addEventListener('click', () => {
            cleanupRoom();
            showContainer(gamePage);
        });

        // Logout
        logoutButton.addEventListener('click', async () => {
            try {
                await signOut(auth);
                showContainer(authContainer);
            } catch (error) {
                showMessage(`Error logging out: ${error.message}`, 'error');
            }
        });

        // Auth State Listener (Continued)
        onAuthStateChanged(auth, async user => {
            if (user) {
                try {
                    const userDoc = await getDoc(doc(db, 'users', user.uid));
                    const username = userDoc.exists() && userDoc.data().username ? userDoc.data().username : 'Player';
                    const avatarUrl = userDoc.exists() ? userDoc.data().avatarUrl : null;
                    updateProfileUI(username, avatarUrl);
                    await updateBalanceUI();
                    if (!user.emailVerified) {
                        verifyEmailPrompt.style.display = 'block';
                        showContainer(dashboard);
                    } else {
                        verifyEmailPrompt.style.display = 'none';
                        const stats = userDoc.exists() && userDoc.data().stats ? userDoc.data().stats : { wins: 0, losses: 0, ties: 0 };
                        statsSummary.textContent = `Total Matches: Wins ${stats.wins}, Losses ${stats.losses}, Ties ${stats.ties}`;
                        showContainer(dashboard);
                    }
                } catch (error) {
                    showMessage(`Error loading user data: ${error.message}`, 'error');
                    showContainer(authContainer);
                }
            } else {
                showContainer(authContainer);
                cleanupRoom();
            }
        });

        // Initialize Game Board
        function initializeGameBoard() {
            gameBoard.querySelectorAll('.cell').forEach(cell => {
                cell.textContent = '';
                cell.className = 'cell';
            });
        }

        // Handle Player Disconnection
        async function handlePlayerDisconnect(roomId, userId) {
            if (!roomId) return;
            try {
                const roomRef = doc(db, 'rooms', roomId);
                const roomDoc = await getDoc(roomRef);
                if (roomDoc.exists()) {
                    const data = roomDoc.data();
                    if (data.player1 === userId || data.player2 === userId) {
                        await updateDoc(roomRef, {
                            status: 'abandoned',
                            board: ['', '', '', '', '', '', '', '', '']
                        });
                        showMessage('Opponent left. Game ended.', 'success');
                        cleanupRoom();
                        showContainer(gamePage);
                    }
                }
            } catch (error) {
                showMessage(`Error handling disconnect: ${error.message}`, 'error');
            }
        }

        // Retry Logic for Joining Room
        async function joinRoomWithRetry(roomId, username, maxRetries = 3) {
            let retries = 0;
            while (retries < maxRetries) {
                try {
                    const roomRef = doc(db, 'rooms', roomId);
                    const roomDoc = await getDoc(roomRef);
                    if (roomDoc.exists() && roomDoc.data().status === 'active') {
                        listenToRoom(roomId, username);
                        showMessage('Room joined!', 'success');
                        return true;
                    }
                    retries++;
                    await new Promise(resolve => setTimeout(resolve, 1000));
                } catch (error) {
                    retries++;
                    if (retries >= maxRetries) {
                        showMessage(`Unable to join room: ${error.message}`, 'error');
                        cleanupRoom();
                        showContainer(gamePage);
                        return false;
                    }
                }
            }
            showMessage('Unable to join room after retries.', 'error');
            cleanupRoom();
            showContainer(gamePage);
            return false;
        }

        // Clean Up on Page Unload
        window.addEventListener('beforeunload', async () => {
            const user = auth.currentUser;
            if (user && currentRoomId) {
                await handlePlayerDisconnect(currentRoomId, user.uid);
            }
            if (currentRoomId) {
                cleanupRoom();
            }
        });

        // Initialize UI
        async function initializeUI() {
            const user = auth.currentUser;
            if (user) {
                try {
                    const userDoc = await getDoc(doc(db, 'users', user.uid));
                    const username = userDoc.exists() && userDoc.data().username ?userDoc.data().username : 'Player';
                    const avatarUrl = userDoc.exists() ? userDoc.data().avatarUrl : null;
                    updateProfileUI(username, avatarUrl);
                    await updateBalanceUI();
                } catch (error) {
                    showMessage(`Error initializing UI: ${error.message}`, 'error');
                }
            }
        }
        initializeUI();
    </script>
</body>
</html>
