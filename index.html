<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Tic-Tac-Toe</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Arial', sans-serif;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(45deg, #0a001a, #001933, #1a000a);
            background-size: 400%;
            animation: bgGlow 15s ease infinite;
            overflow-x: hidden;
        }

        @keyframes bgGlow {
            0% { background-position: 0% 50%; }
            50% { background-position: 400% 50%; }
            100% { background-position: 0% 50%; }
        }

        .container {
            background: rgba(0, 0, 0, 0.9);
            padding: 5%;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(195, 0, 255, 0.8), 0 0 50px rgba(0, 230, 230, 0.8);
            width: min(90%, 500px);
            text-align: center;
            position: relative;
            z-index: 1;
        }

        h2 {
            color: #c300ff;
            text-shadow: 0 0 15px #c300ff, 0 0 25px #00e6e6;
            margin-bottom: 5%;
            font-size: clamp(1.5rem, 5vw, 2rem);
        }

        .input-box {
            margin-bottom: 5%;
            width: 80%;
            margin-left: auto;
            margin-right: auto;
        }

        input[type="text"], input[type="file"], input[type="email"], input[type="password"] {
            width: 100%;
            padding: 3%;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            outline: none;
            border-radius: 25px;
            color: #fff;
            font-size: clamp(0.9rem, 3vw, 1rem);
            box-shadow: 0 0 10px rgba(0, 230, 230, 0.6);
            transition: box-shadow 0.3s ease;
        }

        input[type="file"] {
            display: none;
        }

        input:focus {
            box-shadow: 0 0 25px #c300ff, 0 0 35px #00e6e6;
        }

        button {
            width: 100%;
            padding: 3%;
            background: linear-gradient(45deg, #c300ff, #00e6e6);
            background-size: 200%;
            border: none;
            border-radius: 5px;
            color: #000;
            font-size: clamp(0.9rem, 3vw, 1rem);
            cursor: pointer;
            text-shadow: 0 0 5px #fff;
            box-shadow: 0 0 15px rgba(195, 0, 255, 0.8);
            transition: all 0.3s ease;
            margin-bottom: 3%;
            animation: pulseButton 2s infinite;
        }

        @keyframes pulseButton {
            0% { background-position: 0% 50%; }
            50% { background-position: 200% 50%; }
            100% { background-position: 0% 50%; }
        }

        button:hover {
            box-shadow: 0 0 35px #c300ff, 0 0 55px #00e6e6;
            color: #fff;
        }

        .toggle-text {
            color: #00e6e6;
            cursor: pointer;
            margin-top: 3%;
            display: inline-block;
            text-shadow: 0 0 5px #00e6e6;
            font-size: clamp(0.8rem, 2.5vw, 0.9rem);
        }

        .toggle-text:hover {
            text-decoration: underline;
            text-shadow: 0 0 15px #c300ff;
        }

        .message {
            position: fixed;
            top: 5%;
            right: 5%;
            padding: 3%;
            border-radius: 5px;
            color: #fff;
            font-size: clamp(0.8rem, 2.5vw, 0.9rem);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 1000;
        }

        .message.success {
            background: #33ff66;
            text-shadow: 0 0 5px #33ff66;
        }

        .message.error {
            background: #ff5733;
            text-shadow: 0 0 5px #ff5733;
        }

        .dashboard, .game-page, .game-room, .waiting-area, .profile-page {
            display: none;
            color: #fff;
        }

        .play-btn {
            background: linear-gradient(45deg, #ff5733, #c300ff);
            box-shadow: 0 0 15px rgba(255, 87, 51, 0.8);
        }

        .play-btn:hover {
            box-shadow: 0 0 35px #ff5733, 0 0 55px #c300ff;
        }

        .circle-btn {
            width: clamp(50px, 10vw, 60px);
            height: clamp(50px, 10vw, 60px);
            border-radius: 50%;
            background: linear-gradient(45deg, #c300ff, #00e6e6, #ff5733);
            background-size: 300%;
            border: none;
            color: #fff;
            font-size: clamp(1rem, 3vw, 1.2rem);
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(195, 0, 255, 0.8), 0 0 30px rgba(0, 230, 230, 0.8);
            animation: pulseButton 3s infinite;
            transition: all 0.3s ease;
        }

        .circle-btn:hover {
            box-shadow: 0 0 40px #c300ff, 0 0 60px #00e6e6;
            transform: scale(1.1);
        }

        .win-btn {
            background: linear-gradient(45deg, #33ff66, #c300ff);
            box-shadow: 0 0 15px rgba(51, 255, 102, 0.8);
        }

        .win-btn:hover {
            box-shadow: 0 0 35px #33ff66, 0 0 55px #c300ff;
        }

        .game-board {
            display: grid;
            grid-template-columns: repeat(3, 30%);
            gap: 2%;
            margin: 5% auto;
            width: 90%;
        }

        .cell {
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid #00e6e6;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: clamp(2rem, 8vw, 3rem);
            color: #fff;
            cursor: pointer;
            text-shadow: 0 0 15px #00e6e6;
            transition: all 0.3s ease;
        }

        .cell:hover {
            background: rgba(255, 255, 255, 0.15);
            box-shadow: 0 0 25px #c300ff;
        }

        .cell.x {
            color: #c300ff;
            text-shadow: 0 0 20px #c300ff;
        }

        .cell.o {
            color: #33ff66;
            text-shadow: 0 0 20px #33ff66;
        }

        .room-id {
            color: #ff5733;
            text-shadow: 0 0 5px #ff5733;
            margin-bottom: 5%;
            font-size: clamp(1rem, 3.5vw, 1.2rem);
        }

        .status {
            color: #fff;
            margin-bottom: 5%;
            text-shadow: 0 0 5px #00e6e6;
            font-size: clamp(1rem, 3.5vw, 1.2rem);
        }

        .waiting-area p {
            color: #c300ff;
            text-shadow: 0 0 15px #c300ff;
            font-size: clamp(1.2rem, 4vw, 1.5rem);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        /* Dashboard Layout */
        .dashboard {
            position: relative;
            min-height: 80vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        #profileBtn {
            top: 5%;
            right: 5%;
            background: none;
            background-size: cover;
            color: transparent;
            border: 2px solid #c300ff;
        }

        #walletBtn {
            top: 5%;
            left: 5%;
        }

        .balance-box {
            position: absolute;
            top: 5%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #ff5733;
            border-radius: 10px;
            padding: 2%;
            width: clamp(100px, 25vw, 150px);
            color: #ff5733;
            font-size: clamp(1rem, 3.5vw, 1.2rem);
            font-weight: bold;
            text-shadow: 0 0 15px #ff5733;
            box-shadow: 0 0 25px rgba(255, 87, 51, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #playButton {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: clamp(100px, 20vw, 120px);
            border-radius: 50%;
        }

        #winButton {
            position: absolute;
            bottom: 5%;
            left: 5%;
            width: clamp(50px, 10vw, 60px);
            height: clamp(50px, 10vw, 60px);
            border-radius: 50%;
        }

        #friendsBtn {
            bottom: 5%;
            left: 30%;
        }

        #tournamentsBtn {
            bottom: 5%;
            right: 30%;
        }

        #tasksBtn {
            bottom: 5%;
            right: 5%;
        }

        .dashboard-center {
            width: 80%;
            margin: 20% auto 10% auto;
        }

        /* Profile Page */
        .profile-page {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .profile-pic-circle {
            width: clamp(80px, 20vw, 100px);
            height: clamp(80px, 20vw, 100px);
            border-radius: 50%;
            border: 2px solid #c300ff;
            margin-bottom: 5%;
            background-size: cover;
            background-position: center;
            box-shadow: 0 0 20px rgba(195, 0, 255, 0.8);
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            color: transparent;
        }

        .username-container {
            display: flex;
            align-items: center;
            margin-bottom: 5%;
        }

        .username-display {
            color: #00e6e6;
            font-size: clamp(1rem, 3.5vw, 1.2rem);
            text-shadow: 0 0 10px #00e6e6;
            cursor: pointer;
            padding: 2%;
            border-radius: 5px;
            transition: background 0.3s ease;
        }

        .username-display:hover {
            background: rgba(195, 0, 255, 0.2);
        }

        .edit-icon {
            color: #00e6e6;
            margin-left: 2%;
            font-size: clamp(0.8rem, 2.5vw, 1rem);
            text-shadow: 0 0 5px #00e6e6;
            cursor: pointer;
        }

        .game-history-btn {
            background: linear-gradient(45deg, #ff5733, #c300ff);
            width: 80%;
            padding: 3%;
            border-radius: 5px;
            box-shadow: 0 0 15px rgba(255, 87, 51, 0.8);
        }

        .game-history-btn:hover {
            box-shadow: 0 0 35px #ff5733, 0 0 55px #c300ff;
        }

        @media (max-width: 600px) {
            .container {
                padding: 8%;
                width: 95%;
            }
            h2 {
                font-size: clamp(1.2rem, 4.5vw, 1.5rem);
            }
            button, input {
                padding: 4%;
                font-size: clamp(0.8rem, 2.5vw, 0.9rem);
            }
            .game-board {
                width: 95%;
                grid-template-columns: repeat(3, 31%);
                gap: 1%;
            }
            .cell {
                font-size: clamp(1.5rem, 6vw, 2rem);
            }
            .circle-btn, #playButton, #winButton {
                width: clamp(40px, 8vw, 50px);
                height: clamp(40px, 8vw, 50px);
                font-size: clamp(0.8rem, 2.5vw, 1rem);
            }
            .balance-box {
                width: clamp(80px, 20vw, 120px);
                padding: 3%;
                font-size: clamp(0.8rem, 3vw, 1rem);
            }
            #profileBtn {
                top: 3%;
                right: 3%;
            }
            #walletBtn {
                top: 3%;
                left: 3%;
            }
            .balance-box {
                top: 15%;
            }
            #playButton {
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
            }
            #winButton {
                bottom: 3%;
                left: 3%;
            }
            #friendsBtn {
                bottom: 3%;
                left: 28%;
            }
            #tournamentsBtn {
                bottom: 3%;
                right: 28%;
            }
            #tasksBtn {
                bottom: 3%;
                right: 3%;
            }
            .dashboard-center {
                margin: 25% auto 15% auto;
            }
            .profile-pic-circle {
                width: clamp(60px, 15vw, 80px);
                height: clamp(60px, 15vw, 80px);
            }
            .username-display {
                font-size: clamp(0.8rem, 3vw, 1rem);
            }
            .edit-icon {
                font-size: clamp(0.7rem, 2vw, 0.9rem);
            }
        }
    </style>
</head>
<body>
    <!-- Auth Container -->
    <div class="container" id="authContainer">
        <h2 id="formTitle">Sign Up</h2>
        <div class="input-box">
            <input type="email" id="email" placeholder="Email" required>
        </div>
        <div class="input-box">
            <input type="password" id="password" placeholder="Password" required>
        </div>
        <button id="authButton">Sign Up</button>
        <span class="toggle-text" id="toggleAuth">Already have an account? Login</span>
    </div>

    <!-- Dashboard -->
    <div class="container dashboard" id="dashboard">
        <div class="balance-box">₹0</div>
        <button class="circle-btn" id="profileBtn">Pro</button>
        <button class="circle-btn" id="walletBtn">W</button>
        <button class="circle-btn" id="friendsBtn">Fr</button>
        <button class="circle-btn" id="tournamentsBtn">To</button>
        <button class="circle-btn" id="tasksBtn">T</button>
        <button class="circle-btn play-btn" id="playButton">Play</button>
        <button class="circle-btn win-btn" id="winButton">Win</button>
        <div class="dashboard-center">
            <h2>Welcome, <span id="userDisplay"></span></h2>
            <div id="verifyEmailPrompt" style="display: none;">
                <p style="color: #ff5733; text-shadow: 0 0 5px #ff5733; margin-bottom: 5%;">
                    Please verify your email to play. Check your inbox!
                </p>
                <button id="resendVerification">Resend Verification Email</button>
            </div>
            <button id="logoutButton">Logout</button>
        </div>
    </div>

    <!-- Profile Page -->
    <div class="container profile-page" id="profilePage">
        <h2>Profile</h2>
        <div id="profilePicCircle" class="profile-pic-circle"></div>
        <input type="file" id="profilePicInput" accept="image/*">
        <div class="username-container">
            <span id="usernameDisplay" class="username-display" contenteditable="false">Set Username</span>
            <span class="edit-icon">✏</span>
        </div>
        <button class="game-history-btn" id="gameHistoryBtn">Game History</button>
        <button id="backToDashboardFromProfile">Back to Dashboard</button>
    </div>

    <!-- Game Page -->
    <div class="container game-page" id="gamePage">
        <h2>Play Tic-Tac-Toe</h2>
        <button id="playRandom">Play with Random Player</button>
        <button id="backToDashboard">Back to Dashboard</button>
    </div>

    <!-- Game Room -->
    <div class="container game-room" id="gameRoom">
        <h2>Tic-Tac-Toe</h2>
        <p class="room-id" id="roomIdDisplay"></p>
        <p class="status" id="gameStatus">Waiting for opponent...</p>
        <p id="playersDisplay"></p>
        <div class="game-board" id="gameBoard">
            <div class="cell" data-index="0"></div>
            <div class="cell" data-index="1"></div>
            <div class="cell" data-index="2"></div>
            <div class="cell" data-index="3"></div>
            <div class="cell" data-index="4"></div>
            <div class="cell" data-index="5"></div>
            <div class="cell" data-index="6"></div>
            <div class="cell" data-index="7"></div>
            <div class="cell" data-index="8"></div>
        </div>
        <button id="leaveRoom">Leave Room</button>
    </div>

    <!-- Waiting Area -->
    <div class="container waiting-area" id="waitingArea">
        <h2>Matchmaking</h2>
        <p>Searching for opponent...</p>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-app.js";
        import { 
            getAuth, 
            createUserWithEmailAndPassword, 
            signInWithEmailAndPassword, 
            onAuthStateChanged, 
            signOut, 
            sendEmailVerification 
        } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-auth.js";
        import { 
            getFirestore, 
            doc, 
            setDoc, 
            getDoc, 
            onSnapshot, 
            updateDoc, 
            deleteDoc, 
            collection, 
            addDoc, 
            query, 
            where, 
            getDocs 
        } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-firestore.js";
        import { 
            getStorage, 
            ref, 
            uploadBytes, 
            getDownloadURL 
        } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-storage.js";

        const firebaseConfig = {
            apiKey: "AIzaSyCxUwcTWRApLE7F_LHMXHOrmoQVWabfpgA",
            authDomain: "future-4a5bb.firebaseapp.com",
            projectId: "future-4a5bb",
            storageBucket: "future-4a5bb.firebasestorage.app",
            messagingSenderId: "769026893150",
            appId: "1:769026893150:web:7af5f9679ac495f8d09bcf",
            measurementId: "G-XQ00FD9LZ4"
        };

        let auth, db, storage;
        try {
            const app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
            storage = getStorage(app);
            console.log('Firebase initialized successfully');
        } catch (error) {
            console.error('Firebase initialization error:', error);
            alert('Failed to initialize Firebase. Check console and verify configuration.');
        }

        // DOM Elements
        const authContainer = document.getElementById('authContainer');
        const dashboard = document.getElementById('dashboard');
        const profilePage = document.getElementById('profilePage');
        const gamePage = document.getElementById('gamePage');
        const gameRoom = document.getElementById('gameRoom');
        const waitingArea = document.getElementById('waitingArea');
        const formTitle = document.getElementById('formTitle');
        const authButton = document.getElementById('authButton');
        const toggleAuth = document.getElementById('toggleAuth');
        const emailInput = document.getElementById('email');
        const passwordInput = document.getElementById('password');
        const userDisplay = document.getElementById('userDisplay');
        const usernameDisplay = document.getElementById('usernameDisplay');
        const profilePicCircle = document.getElementById('profilePicCircle');
        const profilePicInput = document.getElementById('profilePicInput');
        const gameHistoryBtn = document.getElementById('gameHistoryBtn');
        const backToDashboardFromProfile = document.getElementById('backToDashboardFromProfile');
        const playButton = document.getElementById('playButton');
        const winButton = document.getElementById('winButton');
        const logoutButton = document.getElementById('logoutButton');
        const playRandom = document.getElementById('playRandom');
        const backToDashboard = document.getElementById('backToDashboard');
        const roomIdDisplay = document.getElementById('roomIdDisplay');
        const gameStatus = document.getElementById('gameStatus');
        const gameBoard = document.getElementById('gameBoard');
        const leaveRoom = document.getElementById('leaveRoom');
        const playersDisplay = document.getElementById('playersDisplay');
        const verifyEmailPrompt = document.getElementById('verifyEmailPrompt');
        const resendVerification = document.getElementById('resendVerification');
        const profileBtn = document.getElementById('profileBtn');

        // Initialize container visibility
        function initializeContainers() {
            console.log('Initializing containers');
            const containers = [authContainer, dashboard, profilePage, gamePage, gameRoom, waitingArea];
            containers.forEach(c => c && (c.style.display = 'none'));
            authContainer.style.display = 'block';
        }
        initializeContainers();

        let isSignUp = true;
        let currentRoomId = null;
        let currentPlayer = null;
        let opponentUsername = null;
        let unsubscribeRoom = null;
        let lastSaveTime = 0;

        // Show Message
        function showMessage(message, type) {
            console.log(`Showing message: ${message} (${type})`);
            const msgDiv = document.createElement('div');
            msgDiv.className = `message ${type}`;
            msgDiv.textContent = message;
            document.body.appendChild(msgDiv);
            msgDiv.style.opacity = '1';
            setTimeout(() => {
                msgDiv.style.opacity = '0';
                setTimeout(() => msgDiv.remove(), 300);
            }, 3000);
        }

        // Show/Hide Containers
        function showContainer(container) {
            console.log(`Showing container: ${container?.id || 'unknown'}`);
            const containers = [authContainer, dashboard, profilePage, gamePage, gameRoom, waitingArea];
            containers.forEach(c => c && (c.style.display = 'none'));
            container.style.display = 'block';
        }

        // Update Profile Circle and Button
        function updateProfileUI(username, avatarUrl) {
            console.log(`Updating profile UI: username=${username}, avatarUrl=${avatarUrl}`);
            if (!profileBtn || !profilePicCircle) {
                console.error('Profile elements not found');
                return;
            }
            const firstLetter = username.charAt(0).toUpperCase() || 'P';
            if (avatarUrl) {
                console.log('Setting profile picture:', avatarUrl);
                profileBtn.style.backgroundImage = `url(${avatarUrl})`;
                profilePicCircle.style.backgroundImage = `url(${avatarUrl})`;
                profileBtn.style.color = 'transparent';
                profilePicCircle.style.color = 'transparent';
            } else {
                console.log('No avatar, using letter fallback for:', username);
                const canvas = document.createElement('canvas');
                const size = 100;
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                ctx.beginPath();
                ctx.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2);
                ctx.fillStyle = '#c300ff';
                ctx.fill();
                ctx.font = 'bold 60px Arial';
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(firstLetter, size / 2, size / 2);
                const canvasUrl = canvas.toDataURL();
                profileBtn.style.backgroundImage = `url(${canvasUrl})`;
                profilePicCircle.style.backgroundImage = `url(${canvasUrl})`;
                profileBtn.style.color = 'transparent';
                profilePicCircle.style.color = 'transparent';
            }
            profileBtn.style.backgroundSize = 'cover';
            profileBtn.style.border = '2px solid #c300ff';
            profilePicCircle.style.backgroundSize = 'cover';
            profilePicCircle.style.border = '2px solid #c300ff';
            userDisplay.textContent = username;
            usernameDisplay.textContent = username;
        }

        // Save Profile to Firebase
        async function saveProfile(username, avatarFile) {
            const now = Date.now();
            if (now - lastSaveTime < 500) {
                console.log('Debouncing save');
                return;
            }
            lastSaveTime = now;
            console.log('Saving profile');
            const user = auth.currentUser;
            if (!user) {
                console.error('No user logged in');
                showMessage('Please log in first', 'error');
                return;
            }
            if (!user.emailVerified) {
                console.error('Email not verified');
                showMessage('Please verify your email first', 'error');
                return;
            }
            try {
                console.log('Saving profile for user:', user.uid);
                const userDocRef = doc(db, 'users', user.uid);
                let userData = { username };
                let avatarUrl = null;

                if (avatarFile) {
                    console.log('Uploading profile picture:', avatarFile.name);
                    const storageRef = ref(storage, `users/${user.uid}/avatar`);
                    const uploadResult = await uploadBytes(storageRef, avatarFile);
                    avatarUrl = await getDownloadURL(uploadResult.ref);
                    console.log('Profile picture uploaded, permanent URL:', avatarUrl);
                    userData.avatarUrl = avatarUrl;
                } else {
                    console.log('No new profile picture, checking existing');
                    const userDoc = await getDoc(userDocRef);
                    avatarUrl = userDoc.exists() && userDoc.data().avatarUrl ? userDoc.data().avatarUrl : null;
                    if (avatarUrl) {
                        console.log('Using existing avatarUrl:', avatarUrl);
                        userData.avatarUrl = avatarUrl;
                    } else {
                        console.log('No existing avatarUrl');
                    }
                }

                console.log('Saving to Firestore:', userData);
                await setDoc(userDocRef, {
                    ...userData,
                    stats: { wins: 0, losses: 0, ties: 0 }
                }, { merge: true });

                console.log('Updating UI with username:', username, 'avatarUrl:', avatarUrl);
                updateProfileUI(username, avatarUrl);
                showMessage('Profile updated!', 'success');
            } catch (error) {
                console.error('Save profile error:', error.code, error.message);
                showMessage(`Error saving profile: ${error.message}`, 'error');
            }
        }

        // Profile Picture Click
        profilePicCircle?.addEventListener('click', () => {
            console.log('Profile picture clicked, opening gallery');
            profilePicInput?.click();
        });

        // Profile Picture Change
        profilePicInput?.addEventListener('change', async (e) => {
            console.log('Profile picture selected');
            const file = e.target.files[0];
            if (file) {
                console.log('Selected file:', file.name);
                const username = usernameDisplay.textContent.trim() || 'Player';
                await saveProfile(username, file);
                profilePicInput.value = '';
            } else {
                console.log('No file selected');
            }
        });

        // Username Editing
        usernameDisplay?.addEventListener('click', () => {
            console.log('Username clicked, enabling edit');
            usernameDisplay.contentEditable = 'true';
            usernameDisplay.focus();
        });

        usernameDisplay?.addEventListener('blur', async () => {
            console.log('Username blur, saving');
            usernameDisplay.contentEditable = 'false';
            const newUsername = usernameDisplay.textContent.trim();
            if (!newUsername) {
                console.error('Username is empty');
                showMessage('Please enter a username', 'error');
                const userDoc = await getDoc(doc(db, 'users', auth.currentUser?.uid));
                usernameDisplay.textContent = userDoc.exists() && userDoc.data().username ? userDoc.data().username : 'Player';
                return;
            }
            await saveProfile(newUsername, null);
        });

        usernameDisplay?.addEventListener('keydown', async (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                usernameDisplay.blur();
            }
        });

        // Profile Button Click
        profileBtn?.addEventListener('click', async () => {
            console.log('Profile button clicked');
            const user = auth.currentUser;
            if (!user) {
                console.error('No user logged in');
                showMessage('Please log in first', 'error');
                showContainer(authContainer);
                return;
            }
            try {
                console.log('Loading profile for user:', user.uid);
                const userDoc = await getDoc(doc(db, 'users', user.uid));
                const username = userDoc.exists() && userDoc.data().username ? userDoc.data().username : 'Player';
                const avatarUrl = userDoc.exists() && userDoc.data().avatarUrl ? userDoc.data().avatarUrl : null;
                console.log('Profile data:', { username, avatarUrl });
                usernameDisplay.textContent = username;
                updateProfileUI(username, avatarUrl);
                showContainer(profilePage);
            } catch (error) {
                console.error('Profile page error:', error.code, error.message);
                showMessage(`Error loading profile: ${error.message}`, 'error');
            }
        });

        // Game History Button (Placeholder)
        gameHistoryBtn?.addEventListener('click', () => {
            console.log('Game history clicked');
            showMessage('Game history not implemented yet', 'error');
        });

        // Back to Dashboard from Profile
        backToDashboardFromProfile?.addEventListener('click', () => {
            console.log('Back to dashboard from profile clicked');
            showContainer(dashboard);
        });

        // Toggle Auth Mode
        toggleAuth.addEventListener('click', () => {
            console.log('Toggle auth clicked');
            isSignUp = !isSignUp;
            formTitle.textContent = isSignUp ? 'Sign Up' : 'Login';
            authButton.textContent = isSignUp ? 'Sign Up' : 'Login';
            toggleAuth.textContent = isSignUp ? 'Already have an account? Login' : 'Need an account? Sign Up';
        });

        // Authentication Handler
        authButton.addEventListener('click', async () => {
            console.log('Auth button clicked');
            const email = emailInput?.value;
            const password = passwordInput?.value;
            if (!email || !password) {
                console.error('Email or password missing');
                showMessage('Please enter email and password', 'error');
                return;
            }
            try {
                if (isSignUp) {
                    const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                    await sendEmailVerification(userCredential.user);
                    showMessage('Sign Up Successful! Please verify your email.', 'success');
                } else {
                    await signInWithEmailAndPassword(auth, email, password);
                    showMessage('Login Successful!', 'success');
                }
                emailInput.value = '';
                passwordInput.value = '';
            } catch (error) {
                console.error('Auth error:', error.code, error.message);
                showMessage(`Error: ${error.message}`, 'error');
            }
        });

        // Resend Verification Email
        resendVerification?.addEventListener('click', async () => {
            console.log('Resend verification clicked');
            const user = auth.currentUser;
            if (user && !user.emailVerified) {
                try {
                    await sendEmailVerification(user);
                    showMessage('Verification email resent! Check your inbox.', 'success');
                } catch (error) {
                    console.error('Resend verification error:', error.code, error.message);
                    showMessage(`Error: ${error.message}`, 'error');
                }
            }
        });

        // Play Button
        playButton.addEventListener('click', async () => {
            console.log('Play button clicked');
            const user = auth.currentUser;
            if (!user) {
                console.error('No user logged in');
                showMessage('Please log in first', 'error');
                showContainer(authContainer);
                return;
            }
            if (!user.emailVerified) {
                console.error('Email not verified');
                showMessage('Please verify your email first', 'error');
                return;
            }
            try {
                const userDoc = await getDoc(doc(db, 'users', user.uid));
                if (userDoc.exists() && userDoc.data().username) {
                    showContainer(gamePage);
                } else {
                    console.log('No username set, redirecting to profile');
                    showMessage('Please set a username first', 'error');
                    showContainer(profilePage);
                }
            } catch (error) {
                console.error('Play button error:', error.code, error.message);
                showMessage(`Error: ${error.message}`, 'error');
            }
        });

        // Back to Dashboard
        backToDashboard.addEventListener('click', () => {
            console.log('Back to dashboard clicked');
            if (!auth.currentUser) {
                console.error('No user logged in');
                showMessage('Please log in first', 'error');
                showContainer(authContainer);
                return;
            }
            showContainer(dashboard);
        });

        // Play with Random Player
        playRandom.addEventListener('click', async () => {
            console.log('Play random clicked');
            const user = auth.currentUser;
            if (!user || !user.emailVerified) {
                console.error('User not logged in or email not verified');
                showMessage('Please verify your email first', 'error');
                showContainer(authContainer);
                return;
            }
            console.log('Starting matchmaking for user:', user.uid);
            let matchmakingId = null;
            try {
                const userDoc = await getDoc(doc(db, 'users', user.uid));
                const username = userDoc.data()?.username || 'Player';
                showContainer(waitingArea);

                // Clean up existing matchmaking entries
                const userEntries = await getDocs(query(collection(db, 'matchmaking'), where('userId', '==', user.uid)));
                for (const entry of userEntries.docs) {
                    console.log('Deleting stale entry:', entry.id);
                    await deleteDoc(doc(db, 'matchmaking', entry.id));
                }

                // Add to matchmaking pool
                const matchmakingData = {
                    userId: user.uid,
                    username,
                    status: 'waiting',
                    timestamp: Date.now()
                };
                const matchmakingRef = await addDoc(collection(db, 'matchmaking'), matchmakingData);
                matchmakingId = matchmakingRef.id;
                console.log('Added to matchmaking pool:', matchmakingId);

                // Listen for matchmaking entry
                let isPaired = false;
                const unsubscribeMatch = onSnapshot(doc(db, 'matchmaking', matchmakingId), async snapshot => {
                    if (!snapshot.exists()) {
                        if (!isPaired) {
                            console.log('Matchmaking entry deleted unexpectedly');
                            showContainer(gamePage);
                            showMessage('Matchmaking canceled.', 'error');
                        }
                        return;
                    }
                    const data = snapshot.data();
                    console.log('Matchmaking entry updated:', data);
                    if (data.status === 'paired' && data.roomId) {
                        isPaired = true;
                        currentRoomId = data.roomId;
                        currentPlayer = data.playerSymbol || 'O';
                        opponentUsername = data.opponentUsername;
                        await deleteDoc(doc(db, 'matchmaking', matchmakingId));
                        unsubscribeMatch();
                        showContainer(gameRoom);
                        roomIdDisplay.textContent = `Room ID: ${currentRoomId}`;
                        listenToRoom(currentRoomId, username);
                        showMessage('Opponent found! Game started.', 'success');
                    }
                }, error => {
                    console.error('Matchmaking listener error:', error);
                    showMessage('Matchmaking failed. Please try again.', 'error');
                    if (matchmakingId) {
                        deleteDoc(doc(db, 'matchmaking', matchmakingId)).catch(err => console.error('Cleanup error:', err));
                    }
                    unsubscribeMatch();
                    showContainer(gamePage);
                });

                // Check for unpaired players
                const now = Date.now();
                const q = query(collection(db, 'matchmaking'), where('status', '==', 'waiting'));
                const existingEntries = await getDocs(q);
                console.log('Existing matchmaking entries:', existingEntries.size);

                const opponentDocs = existingEntries.docs.filter(doc => {
                    const data = doc.data();
                    return data.userId !== user.uid && (now - data.timestamp) < 20000;
                });
                console.log('Filtered opponent entries:', opponentDocs.length);

                if (opponentDocs.length > 0 && !isPaired) {
                    const opponentDoc = opponentDocs[0];
                    const opponent = opponentDoc.data();
                    console.log('Found opponent:', opponent.username);
                    isPaired = true;
                    const roomData = {
                        player1: user.uid,
                        player1Username: username,
                        player2: opponent.userId,
                        player2Username: opponent.username,
                        board: ['', '', '', '', '', '', '', '', ''],
                        turn: 'X',
                        status: 'active',
                        createdAt: Date.now()
                    };
                    const roomRef = await addDoc(collection(db, 'rooms'), roomData);
                    currentRoomId = roomRef.id;
                    currentPlayer = 'X';
                    opponentUsername = opponent.username;

                    await updateDoc(doc(db, 'matchmaking', opponentDoc.id), {
                        status: 'paired',
                        roomId: roomRef.id,
                        playerSymbol: 'O',
                        opponentUsername: username
                    });

                    await deleteDoc(doc(db, 'matchmaking', matchmakingId));
                    unsubscribeMatch();
                    showContainer(gameRoom);
                    roomIdDisplay.textContent = `Room ID: ${roomRef.id}`;
                    listenToRoom(roomRef.id, username);
                    showMessage('Opponent found! Game started.', 'success');
                } else {
                    for (const doc of existingEntries.docs) {
                        if ((now - doc.data().timestamp) >= 20000) {
                            console.log('Deleting stale entry:', doc.id);
                            await deleteDoc(doc(db, 'matchmaking', doc.id));
                        }
                    }
                    setTimeout(() => {
                        if (!isPaired) {
                            console.log('Matchmaking timeout, isPaired:', isPaired);
                            unsubscribeMatch();
                            if (matchmakingId) {
                                deleteDoc(doc(db, 'matchmaking', matchmakingId)).catch(err => console.error('Cleanup error:', err));
                            }
                            showContainer(gamePage);
                            showMessage('No opponent found. Try again later.', 'error');
                        }
                    }, 20000);
                }
            } catch (error) {
                console.error('Play random error:', error.code, error.message);
                showMessage('Matchmaking failed. Please try again.', 'error');
                if (matchmakingId) {
                    deleteDoc(doc(db, 'matchmaking', matchmakingId)).catch(err => console.error('Cleanup error:', err));
                }
                showContainer(gamePage);
            }
        });

        // Check Winner
        function checkWinner(board) {
            console.log('Checking winner for board:', board);
            const winPatterns = [
                [0, 1, 2], [3, 4, 5], [6, 7, 8],
                [0, 3, 6], [1, 4, 7], [2, 5, 8],
                [0, 4, 8], [2, 4, 6]
            ];
            for (const pattern of winPatterns) {
                const [a, b, c] = pattern;
                if (board[a] && board[a] === board[b] && board[b] === board[c]) {
                    return board[a];
                }
            }
            if (board.every(cell => cell !== '')) {
                return 'tie';
            }
            return null;
        }

        // Listen to Room Updates
        function listenToRoom(roomId, username) {
            console.log(`Listening to room: ${roomId}`);
            if (unsubscribeRoom) unsubscribeRoom();
            unsubscribeRoom = onSnapshot(doc(db, 'rooms', roomId), async snapshot => {
                console.log('Room snapshot received');
                if (!snapshot.exists()) {
                    showMessage('Room closed', 'error');
                    cleanupGame();
                    return;
                }
                const data = snapshot.data();
                console.log('Room data:', data, 'Current player:', currentPlayer);
                if (data.status === 'active' && data.player1 && data.player2) {
                    let winner = data.winner || checkWinner(data.board);
                    if (winner && !data.winner) {
                        await updateDoc(doc(db, 'rooms', roomId), { winner, status: 'finished' });
                    }
                    if (gameStatus) {
                        if (data.turn === currentPlayer) {
                            gameStatus.textContent = 'Your turn';
                        } else {
                            gameStatus.textContent = `Opponent's turn (${data.turn})`;
                        }
                    }
                    if (playersDisplay) playersDisplay.textContent = `${data.player1Username} (X) vs ${data.player2Username} (O)`;
                    opponentUsername = currentPlayer === 'X' ? data.player2Username : data.player1Username;
                    renderBoard(data.board);
                    if (winner) {
                        await handleGameEnd(winner, username);
                    }
                }
            }, error => {
                console.error('Room listener error:', error);
                showMessage(`Room error: ${error.message}`, 'error');
            });
        }

        // Render Tic-Tac-Toe Board
        function renderBoard(board) {
            console.log('Rendering board:', board);
            const cells = gameBoard?.querySelectorAll('.cell') || [];
            cells.forEach((cell, index) => {
                cell.textContent = board[index];
                cell.className = 'cell';
                if (board[index] === 'X') cell.classList.add('x');
                if (board[index] === 'O') cell.classList.add('o');
            });
        }

        // Handle Cell Click
        gameBoard.addEventListener('click', async e => {
            console.log('Game board clicked');
            const cell = e.target;
            if (!cell.classList.contains('cell') || !currentRoomId) return;
            const index = cell.dataset.index;
            try {
                const roomDoc = await getDoc(doc(db, 'rooms', currentRoomId));
                const data = roomDoc.data();
                if (!data) {
                    showMessage('Room not found', 'error');
                    return;
                }
                if (data.board[index] !== '' || data.winner || data.status !== 'active') return;
                if ((currentPlayer === 'X' && data.turn !== 'X') || (currentPlayer === 'O' && data.turn !== 'O')) {
                    showMessage('Not your turn!', 'error');
                    return;
                }
                const newBoard = [...data.board];
                newBoard[index] = currentPlayer;
                const newTurn = currentPlayer === 'X' ? 'O' : 'X';
                await updateDoc(doc(db, 'rooms', currentRoomId), {
                    board: newBoard,
                    turn: newTurn
                });
            } catch (error) {
                console.error('Cell click error:', error);
                showMessage(`Error: ${error.message}`, 'error');
            }
        });

        // Handle Game End
        async function handleGameEnd(result, username) {
            console.log(`Game ended: ${result}, Current player: ${currentPlayer}, Username: ${username}`);
            const user = auth.currentUser;
            if (!user || !currentRoomId) {
                console.log('No user or roomId, skipping stats update');
                return;
            }
            try {
                const userDocRef = doc(db, 'users', user.uid);
                const userDoc = await getDoc(userDocRef);
                let stats = userDoc.data()?.stats || { wins: 0, losses: 0, ties: 0 };
                console.log('Current stats:', stats);
                if (result === currentPlayer) {
                    showMessage('You won!', 'success');
                    stats.wins += 1;
                } else if (result === 'tie') {
                    showMessage('Game tied!', 'success');
                    stats.ties += 1;
                } else {
                    showMessage(`${opponentUsername} won!`, 'error');
                    stats.losses += 1;
                }
                console.log('Updating stats to:', stats);
                await updateDoc(userDocRef, { stats });
                await updateDoc(doc(db, 'rooms', currentRoomId), { status: 'finished', winner: result });
                setTimeout(() => {
                    cleanupGame();
                    showContainer(dashboard);
                }, 2000);
            } catch (error) {
                console.error('Game end error:', error.code, error.message);
                showMessage(`Error updating stats: ${error.message}`, 'error');
            }
        }

        // Cleanup Game
        function cleanupGame() {
            console.log('Cleaning up game');
            if (currentRoomId) {
                updateDoc(doc(db, 'rooms', currentRoomId), { status: 'closed' }).catch(error => {
                    console.error('Cleanup error:', error);
                });
                currentRoomId = null;
            }
            if (unsubscribeRoom) {
                unsubscribeRoom();
                unsubscribeRoom = null;
            }
            currentPlayer = null;
            opponentUsername = null;
            if (gameBoard) {
                gameBoard.querySelectorAll('.cell').forEach(cell => {
                    cell.textContent = '';
                    cell.className = 'cell';
                });
            }
            if (gameStatus) gameStatus.textContent = 'Waiting for opponent...';
            if (roomIdDisplay) roomIdDisplay.textContent = '';
            if (playersDisplay) playersDisplay.textContent = '';
            if (auth.currentUser) {
                showContainer(dashboard);
            } else {
                showContainer(authContainer);
            }
        }

        // Leave Room
        leaveRoom.addEventListener('click', () => {
            console.log('Leave room clicked');
            showMessage('Left room', 'success');
            cleanupGame();
        });

        // Auth State Listener
        onAuthStateChanged(auth, async user => {
            console.log('Auth state changed:', user ? `User: ${user.uid}` : 'No user');
            if (user) {
                showContainer(dashboard);
                verifyEmailPrompt.style.display = user.emailVerified ? 'none' : 'block';
                playButton.style.display = user.emailVerified ? 'block' : 'none';
                try {
                    console.log('Fetching user data for:', user.uid);
                    const userDoc = await getDoc(doc(db, 'users', user.uid));
                    const username = userDoc.exists() && userDoc.data().username ? userDoc.data().username : 'Player';
                    const avatarUrl = userDoc.exists() && userDoc.data().avatarUrl ? userDoc.data().avatarUrl : null;
                    console.log('User data:', { username, avatarUrl });
                    updateProfileUI(username, avatarUrl);
                } catch (error) {
                    console.error('Fetch user data error:', error.code, error.message);
                    showMessage(`Error fetching user data: ${error.message}`, 'error');
                    updateProfileUI('Player', null);
                }
            } else {
                showContainer(authContainer);
                userDisplay.textContent = '';
                usernameDisplay.textContent = 'Set Username';
                updateProfileUI('Player', null);
                cleanupGame();
            }
        });

        // Logout
        logoutButton.addEventListener('click', async () => {
            console.log('Logout button clicked');
            try {
                await signOut(auth);
                showMessage('Logged out successfully!', 'success');
                showContainer(authContainer);
                cleanupGame();
            } catch (error) {
                console.error('Logout error:', error.code, error.message);
                showMessage(`Logout failed: ${error.message}`, 'error');
            }
        });
    </script>
</body>
</html>
