<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Firebase Auth & Tic-Tac-Toe</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Montserrat', 'Arial', sans-serif; /* MPL-inspired modern font */
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1C2526 0%, #2A2E6B 100%); /* WinZO dark with MPL gradient */
            background-size: 200% 200%;
            animation: gradientWave 15s ease infinite; /* Dynamic background */
            overflow-x: hidden;
        }

        /* MPL-inspired gradient wave animation */
        @keyframes gradientWave {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .container {
            background: rgba(30, 35, 55, 0.9); /* Semi-transparent, WinZO-inspired dark */
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 88, 255, 0.3); /* MPL blue glow */
            width: 420px; /* Slightly wider for comfort */
            text-align: center;
            position: relative;
            z-index: 1;
            backdrop-filter: blur(10px); /* Glassmorphism for premium feel */
            border: 1px solid rgba(0, 255, 132, 0.2); /* WinZO green accent */
        }

        h2 {
            color: #FFD700; /* WinZO gold for headers */
            text-shadow: 0 0 8px rgba(255, 215, 0, 0.7);
            margin-bottom: 25px;
            font-size: 24px;
            font-weight: 700;
        }

        .input-box {
            margin-bottom: 20px;
        }

        input {
            width: 100%;
            padding: 12px 15px;
            background: rgba(255, 255, 255, 0.1); /* MPL translucent input */
            border: none;
            outline: none;
            border-radius: 30px;
            color: #FFFFFF;
            font-size: 16px;
            box-shadow: inset 0 0 5px rgba(0, 255, 132, 0.3); /* WinZO green glow */
            transition: all 0.3s ease;
        }

        input::placeholder {
            color: rgba(255, 255, 255, 0.5); /* Subtle placeholder */
        }

        input:focus {
            box-shadow: 0 0 15px #0058FF; /* MPL blue focus */
            background: rgba(255, 255, 255, 0.15);
        }

        button {
            width: 100%;
            padding: 12px;
            background: linear-gradient(45deg, #0058FF, #7B00FF); /* MPL blue-to-purple */
            border: none;
            border-radius: 10px;
            color: #FFFFFF;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }

        button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.6s ease, height 0.6s ease;
        }

        button:hover::before {
            width: 300px;
            height: 300px; /* WinZO-inspired button shine */
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 88, 255, 0.5); /* MPL glow */
        }

        .toggle-text {
            color: #00FF84; /* WinZO green */
            cursor: pointer;
            margin-top: 15px;
            display: inline-block;
            font-size: 14px;
            text-shadow: 0 0 5px rgba(0, 255, 132, 0.5);
            transition: color 0.3s ease;
        }

        .toggle-text:hover {
            color: #FFD700; /* WinZO gold on hover */
            text-decoration: none;
        }

        .message {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 25px;
            border-radius: 12px;
            color: #FFFFFF;
            font-size: 16px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            opacity: 0;
            transition: opacity 0.3s ease, transform 0.3s ease;
            z-index: 1000;
            transform: translateY(-20px);
        }

        .message.success {
            background: linear-gradient(45deg, #00FF84, #00C4B4); /* WinZO green-teal */
            text-shadow: 0 0 5px rgba(0, 255, 132, 0.7);
        }

        .message.error {
            background: linear-gradient(45deg, #FF3B30, #FF9500); /* Vibrant red-orange */
            text-shadow: 0 0 5px rgba(255, 59, 48, 0.7);
        }

        .message[style*="opacity: 1"] {
            transform: translateY(0); /* Slide-in effect */
        }

        .dashboard, .game-page, .friend-options, .game-room, .waiting-area {
            display: none;
            color: #FFFFFF;
        }

        .dashboard h2, .game-page h2, .friend-options h2, .game-room h2, .waiting-area h2 {
            margin-bottom: 30px;
        }

        .play-btn {
            background: linear-gradient(45deg, #FF3B30, #FF9500); /* Unique fiery gradient */
            margin-top: 20px;
        }

        .play-btn:hover {
            box-shadow: 0 8px 20px rgba(255, 59, 48, 0.5);
        }

        .game-board {
            display: grid;
            grid-template-columns: repeat(3, 100px);
            grid-gap: 8px;
            margin: 25px auto;
            width: 324px;
        }

        .cell {
            width: 100px;
            height: 100px;
            background: rgba(255, 255, 255, 0.05); /* Translucent for depth */
            border: 2px solid #7B00FF; /* MPL purple border */
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 48px;
            color: #FFFFFF;
            cursor: pointer;
            transition: all 0.3s ease;
            text-shadow: 0 0 8px rgba(255, 255, 255, 0.5);
        }

        .cell:hover {
            background: rgba(123, 0, 255, 0.2); /* MPL purple hover */
            transform: scale(1.05);
        }

        .cell.x {
            color: #FFD700; /* WinZO gold for X */
            text-shadow: 0 0 12px rgba(255, 215, 0, 0.8);
        }

        .cell.o {
            color: #00FF84; /* WinZO green for O */
            text-shadow: 0 0 12px rgba(0, 255, 132, 0.8);
        }

        .room-id {
            color: #00FF84; /* WinZO green */
            text-shadow: 0 0 6px rgba(0, 255, 132, 0.7);
            margin-bottom: 20px;
            font-size: 18px;
        }

        .status {
            color: #FFFFFF;
            margin-bottom: 20px;
            text-shadow: 0 0 6px rgba(0, 88, 255, 0.5); /* MPL blue */
            font-size: 18px;
        }

        .waiting-area p {
            color: #FFD700; /* WinZO gold */
            text-shadow: 0 0 8px rgba(255, 215, 0, 0.7);
            font-size: 22px;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }

        /* Profile Card Styles */
        .profile-card {
            position: absolute;
            top: 15px;
            left: 15px;
            background: linear-gradient(135deg, #2A2E6B, #1E2337); /* MPL-to-WinZO gradient */
            border: 2px solid #FFD700; /* WinZO gold border */
            border-radius: 15px;
            padding: 15px;
            width: 180px;
            text-align: left;
            box-shadow: 0 4px 15px rgba(0, 88, 255, 0.3); /* MPL blue shadow */
            transition: all 0.3s ease;
            backdrop-filter: blur(5px); /* Holographic effect */
        }

        .profile-card:hover {
            box-shadow: 0 8px 25px rgba(0, 88, 255, 0.5);
            transform: translateY(-3px); /* Lift on hover */
        }

        .profile-username {
            color: #00FF84; /* WinZO green */
            font-size: 18px;
            font-weight: 700;
            text-shadow: 0 0 6px rgba(0, 255, 132, 0.7);
            margin-bottom: 12px;
        }

        .profile-stats {
            color: #FFFFFF;
            font-size: 14px;
            line-height: 1.5;
        }

        .profile-stats span {
            color: #FFD700; /* WinZO gold for numbers */
            text-shadow: 0 0 5px rgba(255, 215, 0, 0.5);
        }

        .profile-settings {
            margin-top: 10px;
            text-align: right;
        }

        .profile-settings-icon {
            color: #7B00FF; /* MPL purple */
            font-size: 18px;
            cursor: pointer;
            text-shadow: 0 0 5px rgba(123, 0, 255, 0.5);
            transition: all 0.3s ease;
        }

        .profile-settings-icon:hover {
            color: #00FF84; /* WinZO green on hover */
            text-shadow: 0 0 10px rgba(0, 255, 132, 0.8);
            transform: rotate(90deg); /* Playful spin */
        }
    </style>
</head>
<body>
    <!-- Auth Container -->
    <div class="container" id="authContainer">
        <h2 id="formTitle">Sign Up</h2>
        <div class="input-box">
            <input type="email" id="email" placeholder="Email" required>
        </div>
        <div class="input-box">
            <input type="password" id="password" placeholder="Password" required>
        </div>
        <button id="authButton">Sign Up</button>
        <span class="toggle-text" id="toggleAuth">Already have an account? Login</span>
    </div>

    <!-- Dashboard -->
    <div class="container dashboard" id="dashboard">
        <div class="profile-card" id="profileCard">
            <div class="profile-username" id="profileUsername">Loading...</div>
            <div class="profile-stats">
                Wins: <span id="profileWins">0</span><br>
                Losses: <span id="profileLosses">0</span><br>
                Ties: <span id="profileTies">0</span>
            </div>
            <div class="profile-settings">
                <span class="profile-settings-icon" id="profileSettings">⚙️</span>
            </div>
        </div>
        <h2>Welcome, <span id="userDisplay"></span></h2>
        <div class="input-box">
            <input type="text" id="username" placeholder="Set Username">
        </div>
        <button id="saveUsername">Save Username</button>
        <button class="play-btn" id="playButton">Play</button>
        <button id="logoutButton">Logout</button>
    </div>

    <!-- Game Page -->
    <div class="container game-page" id="gamePage">
        <h2>Choose Game Mode</h2>
        <button id="playWithFriend">Play with Friend</button>
        <button id="playRandom">Play with Random Player</button>
        <button id="backToDashboard">Back to Dashboard</button>
    </div>

    <!-- Friend Options -->
    <div class="container friend-options" id="friendOptions">
        <h2>Play with Friend</h2>
        <button id="createRoom">Create Room</button>
        <div class="input-box">
            <input type="text" id="roomIdInput" placeholder="Enter Room ID">
        </div>
        <button id="joinRoom">Join Room</button>
        <button id="backToGamePage">Back</button>
    </div>

    <!-- Game Room -->
    <div class="container game-room" id="gameRoom">
        <h2>Tic-Tac-Toe</h2>
        <p class="room-id" id="roomIdDisplay"></p>
        <p class="status" id="gameStatus">Waiting for opponent...</p>
        <p id="playersDisplay"></p>
        <div class="game-board" id="gameBoard">
            <div class="cell" data-index="0"></div>
            <div class="cell" data-index="1"></div>
            <div class="cell" data-index="2"></div>
            <div class="cell" data-index="3"></div>
            <div class="cell" data-index="4"></div>
            <div class="cell" data-index="5"></div>
            <div class="cell" data-index="6"></div>
            <div class="cell" data-index="7"></div>
            <div class="cell" data-index="8"></div>
        </div>
        <button id="leaveRoom">Leave Room</button>
    </div>

    <!-- Waiting Area -->
    <div class="container waiting-area" id="waitingArea">
        <h2>Matchmaking</h2>
        <p>Searching for opponent...</p>
    </div>

    <script type="module">
        // Firebase SDK Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-app.js";
        import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, onSnapshot, updateDoc, deleteDoc, collection, addDoc, query, where, getDocs } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-firestore.js";

        // Firebase Configuration - REPLACE WITH YOUR OWN CONFIG
        // For Firebase JS SDK v7.20.0 and later, measurementId is optional
        const firebaseConfig = {
        apiKey: "AIzaSyDs2taPm-p2O-dYdBToYwq7vZBUSDNISyg",
        authDomain: "earn-itt.firebaseapp.com",
        projectId: "earn-itt",
        storageBucket: "earn-itt.firebasestorage.app",
        messagingSenderId: "785360520679",
        appId: "1:785360520679:web:ac2e2710ece34591a52942",
        measurementId: "G-P4Q2KYTBBM"
        };

        // Initialize Firebase
        let auth, db;
        try {
            const app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
            console.log('Firebase initialized successfully');
        } catch (error) {
            console.error('Firebase initialization error:', error);
            alert('Failed to initialize Firebase. Check console and verify configuration.');
        }

        // DOM Elements
        const authContainer = document.getElementById('authContainer');
        const dashboard = document.getElementById('dashboard');
        const gamePage = document.getElementById('gamePage');
        const friendOptions = document.getElementById('friendOptions');
        const gameRoom = document.getElementById('gameRoom');
        const waitingArea = document.getElementById('waitingArea');
        const formTitle = document.getElementById('formTitle');
        const authButton = document.getElementById('authButton');
        const toggleAuth = document.getElementById('toggleAuth');
        const emailInput = document.getElementById('email');
        const passwordInput = document.getElementById('password');
        const userDisplay = document.getElementById('userDisplay');
        const usernameInput = document.getElementById('username');
        const saveUsernameButton = document.getElementById('saveUsername');
        const playButton = document.getElementById('playButton');
        const logoutButton = document.getElementById('logoutButton');
        const playWithFriend = document.getElementById('playWithFriend');
        const playRandom = document.getElementById('playRandom');
        const backToDashboard = document.getElementById('backToDashboard');
        const createRoom = document.getElementById('createRoom');
        const joinRoom = document.getElementById('joinRoom');
        const roomIdInput = document.getElementById('roomIdInput');
        const backToGamePage = document.getElementById('backToGamePage');
        const roomIdDisplay = document.getElementById('roomIdDisplay');
        const gameStatus = document.getElementById('gameStatus');
        const gameBoard = document.getElementById('gameBoard');
        const leaveRoom = document.getElementById('leaveRoom');
        const playersDisplay = document.getElementById('playersDisplay');
        const profileCard = document.getElementById('profileCard');
        const profileUsername = document.getElementById('profileUsername');
        const profileWins = document.getElementById('profileWins');
        const profileLosses = document.getElementById('profileLosses');
        const profileTies = document.getElementById('profileTies');
        const profileSettings = document.getElementById('profileSettings');

        // Verify DOM elements
        if (!authContainer) console.error('authContainer not found');
        if (!dashboard) console.error('dashboard not found');
        if (!authButton) console.error('authButton not found');
        if (!logoutButton) console.error('logoutButton not found');
        if (!roomIdInput) console.error('roomIdInput not found');
        if (!profileCard) console.error('profileCard not found');

        // Initialize container visibility
        function initializeContainers() {
            console.log('Initializing containers');
            const containers = [authContainer, dashboard, gamePage, friendOptions, gameRoom, waitingArea];
            containers.forEach(c => {
                if (c) c.style.display = 'none';
            });
            if (authContainer) authContainer.style.display = 'block';
        }

        // Call initializeContainers immediately
        initializeContainers();

        let isSignUp = true;
        let currentRoomId = null;
        let currentPlayer = null;
        let opponentUsername = null;
        let unsubscribeRoom = null;

        // Show Message Function
        function showMessage(message, type) {
            console.log(`Showing message: ${message} (${type})`);
            const msgDiv = document.createElement('div');
            msgDiv.className = `message ${type}`;
            msgDiv.textContent = message;
            document.body.appendChild(msgDiv);
            msgDiv.style.opacity = '1';
            setTimeout(() => {
                msgDiv.style.opacity = '0';
                setTimeout(() => msgDiv.remove(), 300);
            }, 3000);
        }

        // Show/Hide Containers
        function showContainer(container) {
            console.log(`Showing container: ${container?.id || 'unknown'}`);
            const containers = [authContainer, dashboard, gamePage, friendOptions, gameRoom, waitingArea];
            containers.forEach(c => {
                if (c) c.style.display = 'none';
            });
            if (container) container.style.display = 'block';
        }

        // Toggle Auth Mode
        if (toggleAuth) {
            toggleAuth.addEventListener('click', () => {
                console.log('Toggle auth clicked');
                isSignUp = !isSignUp;
                if (formTitle) formTitle.textContent = isSignUp ? 'Sign Up' : 'Login';
                if (authButton) authButton.textContent = isSignUp ? 'Sign Up' : 'Login';
                toggleAuth.textContent = isSignUp ? 'Already have an account? Login' : 'Need an account? Sign Up';
            });
        }

        // Authentication Handler
        if (authButton) {
            authButton.addEventListener('click', async () => {
                console.log('Auth button clicked');
                const email = emailInput?.value;
                const password = passwordInput?.value;
                if (!email || !password) {
                    showMessage('Please enter email and password', 'error');
                    return;
                }
                try {
                    if (isSignUp) {
                        await createUserWithEmailAndPassword(auth, email, password);
                        showMessage('Sign Up Successful!', 'success');
                    } else {
                        await signInWithEmailAndPassword(auth, email, password);
                        showMessage('Login Successful!', 'success');
                    }
                    if (emailInput) emailInput.value = '';
                    if (passwordInput) passwordInput.value = '';
                } catch (error) {
                    console.error('Auth error:', error.code, error.message);
                    showMessage(`Error: ${error.message}`, 'error');
                }
            });
        }

        // Save Username
        if (saveUsernameButton) {
            saveUsernameButton.addEventListener('click', async () => {
                console.log('Save username clicked');
                const username = usernameInput?.value.trim();
                if (!username) {
                    showMessage('Please enter a username', 'error');
                    return;
                }
                try {
                    const user = auth.currentUser;
                    if (user) {
                        await setDoc(doc(db, 'users', user.uid), { 
                            username, 
                            stats: { wins: 0, losses: 0, ties: 0 } 
                        }, { merge: true });
                        showMessage('Username saved!', 'success');
                        if (usernameInput) usernameInput.value = '';
                        if (userDisplay) userDisplay.textContent = username;
                        if (profileUsername) profileUsername.textContent = username;
                    } else {
                        showMessage('Please log in first', 'error');
                        showContainer(authContainer);
                    }
                } catch (error) {
                    console.error('Save username error:', error);
                    showMessage(`Error: ${error.message}`, 'error');
                }
            });
        }

        // Play Button
        if (playButton) {
            playButton.addEventListener('click', async () => {
                console.log('Play button clicked');
                const user = auth.currentUser;
                if (!user) {
                    showMessage('Please log in first', 'error');
                    showContainer(authContainer);
                    return;
                }
                try {
                    const userDoc = await getDoc(doc(db, 'users', user.uid));
                    if (userDoc.exists() && userDoc.data().username) {
                        showContainer(gamePage);
                    } else {
                        showMessage('Please set a username first', 'error');
                    }
                } catch (error) {
                    console.error('Play button error:', error);
                    showMessage(`Error: ${error.message}`, 'error');
                }
            });
        }

        // Back to Dashboard
        if (backToDashboard) {
            backToDashboard.addEventListener('click', () => {
                console.log('Back to dashboard clicked');
                if (!auth.currentUser) {
                    showMessage('Please log in first', 'error');
                    showContainer(authContainer);
                    return;
                }
                showContainer(dashboard);
            });
        }

        // Play with Friend
        if (playWithFriend) {
            playWithFriend.addEventListener('click', () => {
                console.log('Play with friend clicked');
                if (!auth.currentUser) {
                    showMessage('Please log in first', 'error');
                    showContainer(authContainer);
                    return;
                }
                showContainer(friendOptions);
            });
        }

        // Back to Game Page
        if (backToGamePage) {
            backToGamePage.addEventListener('click', () => {
                console.log('Back to game page clicked');
                if (!auth.currentUser) {
                    showMessage('Please log in first', 'error');
                    showContainer(authContainer);
                    return;
                }
                showContainer(gamePage);
            });
        }

        // Create Room
        if (createRoom) {
            createRoom.addEventListener('click', async () => {
                console.log('Create room clicked');
                const user = auth.currentUser;
                if (!user) {
                    showMessage('Please log in first', 'error');
                    showContainer(authContainer);
                    return;
                }
                console.log('Creating room for user:', user.uid);
                try {
                    const userDoc = await getDoc(doc(db, 'users', user.uid));
                    const username = userDoc.data()?.username || 'Player';
                    const roomData = {
                        player1: user.uid,
                        player1Username: username,
                        player2: null,
                        player2Username: null,
                        board: ['', '', '', '', '', '', '', '', ''],
                        turn: 'X',
                        status: 'waiting',
                        createdAt: Date.now()
                    };
                    console.log('Room data:', roomData);
                    const roomRef = await addDoc(collection(db, 'rooms'), roomData);
                    currentRoomId = roomRef.id;
                    currentPlayer = 'X';
                    showContainer(gameRoom);
                    if (roomIdDisplay) roomIdDisplay.textContent = `Room ID: ${currentRoomId}`;
                    if (gameStatus) gameStatus.textContent = 'Waiting for opponent...';
                    listenToRoom(currentRoomId, username);
                    showMessage('Room created! Share the Room ID.', 'success');
                } catch (error) {
                    console.error('Create room error:', error.code, error.message);
                    showMessage(`Error creating room: ${error.message}`, 'error');
                }
            });
        }

        // Join Room with Input Box
        if (joinRoom) {
            joinRoom.addEventListener('click', async () => {
                console.log('Join room clicked');
                const user = auth.currentUser;
                if (!user) {
                    showMessage('Please log in first', 'error');
                    showContainer(authContainer);
                    return;
                }
                const roomId = roomIdInput?.value.trim();
                if (!roomId) {
                    showMessage('Please enter a Room ID', 'error');
                    return;
                }
                console.log('Joining room:', roomId, 'User:', user.uid);
                try {
                    const userDoc = await getDoc(doc(db, 'users', user.uid));
                    const username = userDoc.data()?.username || 'Player';
                    const roomDoc = await getDoc(doc(db, 'rooms', roomId));
                    if (!roomDoc.exists()) {
                        showMessage('Room not found', 'error');
                        return;
                    }
                    const roomData = roomDoc.data();
                    console.log('Room data:', roomData);
                    if (roomData.player2) {
                        showMessage('Room is full', 'error');
                        return;
                    }
                    if (roomData.player1 === user.uid) {
                        showMessage('You cannot join your own room', 'error');
                        return;
                    }
                    await updateDoc(doc(db, 'rooms', roomId), {
                        player2: user.uid,
                        player2Username: username,
                        status: 'active'
                    });
                    currentRoomId = roomId;
                    currentPlayer = 'O';
                    showContainer(gameRoom);
                    if (roomIdDisplay) roomIdDisplay.textContent = `Room ID: ${roomId}`;
                    listenToRoom(roomId, username);
                    showMessage('Joined room successfully!', 'success');
                    if (roomIdInput) roomIdInput.value = '';
                } catch (error) {
                    console.error('Join room error:', error.code, error.message);
                    showMessage(`Error joining room: ${error.message}`, 'error');
                }
            });
        }

        // Play with Random Player
        if (playRandom) {
            playRandom.addEventListener('click', async () => {
                console.log('Play random clicked');
                const user = auth.currentUser;
                if (!user) {
                    showMessage('Please log in first', 'error');
                    showContainer(authContainer);
                    return;
                }
                console.log('Starting matchmaking for user:', user.uid);
                let matchmakingId = null;
                try {
                    const userDoc = await getDoc(doc(db, 'users', user.uid));
                    const username = userDoc.data()?.username || 'Player';
                    showContainer(waitingArea);

                    // Clean up any existing matchmaking entries for this user
                    const userEntries = await getDocs(query(collection(db, 'matchmaking'), where('userId', '==', user.uid)));
                    for (const entry of userEntries.docs) {
                        console.log('Deleting stale entry:', entry.id);
                        await deleteDoc(doc(db, 'matchmaking', entry.id));
                    }

                    // Add self to matchmaking pool
                    const matchmakingData = {
                        userId: user.uid,
                        username,
                        status: 'waiting',
                        timestamp: Date.now()
                    };
                    console.log('Adding to matchmaking:', matchmakingData);
                    const matchmakingRef = await addDoc(collection(db, 'matchmaking'), matchmakingData);
                    matchmakingId = matchmakingRef.id;
                    console.log('Added to matchmaking pool:', matchmakingId);

                    // Listen for own matchmaking entry
                    let isPaired = false;
                    const unsubscribeMatch = onSnapshot(doc(db, 'matchmaking', matchmakingId), async snapshot => {
                        if (!snapshot.exists()) {
                            if (!isPaired) {
                                console.log('Matchmaking entry deleted unexpectedly');
                                showContainer(gamePage);
                                showMessage('Matchmaking canceled.', 'error');
                            }
                            return;
                        }
                        const data = snapshot.data();
                        console.log('Matchmaking entry updated:', data);
                        if (data.status === 'paired' && data.roomId) {
                            isPaired = true;
                            currentRoomId = data.roomId;
                            currentPlayer = data.playerSymbol || 'O';
                            opponentUsername = data.opponentUsername;
                            await deleteDoc(doc(db, 'matchmaking', matchmakingId));
                            unsubscribeMatch();
                            showContainer(gameRoom);
                            if (roomIdDisplay) roomIdDisplay.textContent = `Room ID: ${currentRoomId}`;
                            listenToRoom(currentRoomId, username);
                            showMessage('Opponent found! Game started.', 'success');
                        }
                    }, error => {
                        console.error('Matchmaking listener error:', error);
                        showMessage('Matchmaking failed. Please try again.', 'error');
                        if (matchmakingId) {
                            deleteDoc(doc(db, 'matchmaking', matchmakingId)).catch(err => console.error('Cleanup error:', err));
                        }
                        unsubscribeMatch();
                        showContainer(gamePage);
                    });

                    // Check for existing unpaired players
                    const now = Date.now();
                    const q = query(collection(db, 'matchmaking'), where('status', '==', 'waiting'));
                    const existingEntries = await getDocs(q);
                    console.log('Existing matchmaking entries:', existingEntries.size);

                    const opponentDocs = existingEntries.docs.filter(doc => {
                        const data = doc.data();
                        return data.userId !== user.uid && (now - data.timestamp) < 20000;
                    });
                    console.log('Filtered opponent entries:', opponentDocs.length);

                    if (opponentDocs.length > 0 && !isPaired) {
                        // Pair with the first valid opponent
                        const opponentDoc = opponentDocs[0];
                        const opponent = opponentDoc.data();
                        console.log('Found opponent:', opponent.username);
                        isPaired = true;
                        const roomData = {
                            player1: user.uid,
                            player1Username: username,
                            player2: opponent.userId,
                            player2Username: opponent.username,
                            board: ['', '', '', '', '', '', '', '', ''],
                            turn: 'X',
                            status: 'active',
                            createdAt: Date.now()
                        };
                        console.log('Creating room with data:', roomData);
                        const roomRef = await addDoc(collection(db, 'rooms'), roomData);
                        currentRoomId = roomRef.id;
                        currentPlayer = 'X';
                        opponentUsername = opponent.username;

                        // Update opponent's matchmaking entry
                        await updateDoc(doc(db, 'matchmaking', opponentDoc.id), {
                            status: 'paired',
                            roomId: roomRef.id,
                            playerSymbol: 'O',
                            opponentUsername: username
                        });

                        await deleteDoc(doc(db, 'matchmaking', matchmakingId));
                        unsubscribeMatch();
                        showContainer(gameRoom);
                        if (roomIdDisplay) roomIdDisplay.textContent = `Room ID: ${roomRef.id}`;
                        listenToRoom(roomRef.id, username);
                        showMessage('Opponent found! Game started.', 'success');
                    } else {
                        // Clean up stale entries
                        for (const doc of existingEntries.docs) {
                            if ((now - doc.data().timestamp) >= 20000) {
                                console.log('Deleting stale entry:', doc.id);
                                await deleteDoc(doc(db, 'matchmaking', doc.id));
                            }
                        }
                        // Timeout after 20 seconds
                        setTimeout(() => {
                            if (!isPaired) {
                                console.log('Matchmaking timeout, isPaired:', isPaired);
                                unsubscribeMatch();
                                if (matchmakingId) {
                                    deleteDoc(doc(db, 'matchmaking', matchmakingId)).catch(err => console.error('Cleanup error:', err));
                                }
                                showContainer(gamePage);
                                showMessage('No opponent found. Try again later.', 'error');
                            }
                        }, 20000);
                    }
                } catch (error) {
                    console.error('Play random error:', error.code, error.message);
                    showMessage('Matchmaking failed. Please try again.', 'error');
                    if (matchmakingId) {
                        deleteDoc(doc(db, 'matchmaking', matchmakingId)).catch(err => console.error('Cleanup error:', err));
                    }
                    showContainer(gamePage);
                }
            });
        }

        // Check Winner
        function checkWinner(board) {
            console.log('Checking winner for board:', board);
            const winPatterns = [
                [0, 1, 2], [3, 4, 5], [6, 7, 8], // Rows
                [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columns
                [0, 4, 8], [2, 4, 6]             // Diagonals
            ];
            for (const pattern of winPatterns) {
                const [a, b, c] = pattern;
                if (board[a] && board[a] === board[b] && board[b] === board[c]) {
                    return board[a]; // Returns 'X' or 'O'
                }
            }
            if (board.every(cell => cell !== '')) {
                return 'tie';
            }
            return null;
        }

        // Listen to Room Updates
        function listenToRoom(roomId, username) {
            console.log(`Listening to room: ${roomId}`);
            if (unsubscribeRoom) unsubscribeRoom();
            unsubscribeRoom = onSnapshot(doc(db, 'rooms', roomId), async snapshot => {
                console.log('Room snapshot received');
                if (!snapshot.exists()) {
                    showMessage('Room closed', 'error');
                    cleanupGame();
                    return;
                }
                const data = snapshot.data();
                console.log('Room data:', data, 'Current player:', currentPlayer);
                if (data.status === 'active' && data.player1 && data.player2) {
                    // Check for winner
                    let winner = data.winner || checkWinner(data.board);
                    if (winner && !data.winner) {
                        await updateDoc(doc(db, 'rooms', roomId), { winner, status: 'finished' });
                    }
                    if (gameStatus) {
                        if (data.turn === currentPlayer) {
                            gameStatus.textContent = 'Your turn';
                        } else {
                            gameStatus.textContent = `Opponent's turn (${data.turn})`;
                        }
                    }
                    if (playersDisplay) playersDisplay.textContent = `${data.player1Username} (X) vs ${data.player2Username} (O)`;
                    opponentUsername = currentPlayer === 'X' ? data.player2Username : data.player1Username;
                    renderBoard(data.board);
                    if (winner) {
                        await handleGameEnd(winner, username);
                    }
                }
            }, error => {
                console.error('Room listener error:', error);
                showMessage(`Room error: ${error.message}`, 'error');
            });
        }

        // Render Tic-Tac-Toe Board
        function renderBoard(board) {
            console.log('Rendering board:', board);
            const cells = gameBoard?.querySelectorAll('.cell') || [];
            cells.forEach((cell, index) => {
                cell.textContent = board[index];
                cell.className = 'cell';
                if (board[index] === 'X') cell.classList.add('x');
                if (board[index] === 'O') cell.classList.add('o');
            });
        }

        // Handle Cell Click
        if (gameBoard) {
            gameBoard.addEventListener('click', async e => {
                console.log('Game board clicked');
                const cell = e.target;
                if (!cell.classList.contains('cell') || !currentRoomId) return;
                const index = cell.dataset.index;
                try {
                    const roomDoc = await getDoc(doc(db, 'rooms', currentRoomId));
                    const data = roomDoc.data();
                    if (!data) {
                        showMessage('Room not found', 'error');
                        return;
                    }
                    if (data.board[index] !== '' || data.winner || data.status !== 'active') return;
                    if ((currentPlayer === 'X' && data.turn !== 'X') || (currentPlayer === 'O' && data.turn !== 'O')) {
                        showMessage('Not your turn!', 'error');
                        return;
                    }
                    const newBoard = [...data.board];
                    newBoard[index] = currentPlayer;
                    const newTurn = currentPlayer === 'X' ? 'O' : 'X';
                    await updateDoc(doc(db, 'rooms', currentRoomId), {
                        board: newBoard,
                        turn: newTurn
                    });
                } catch (error) {
                    console.error('Cell click error:', error);
                    showMessage(`Error: ${error.message}`, 'error');
                }
            });
        }

        // Handle Game End
        async function handleGameEnd(result, username) {
            console.log(`Game ended: ${result}, Current player: ${currentPlayer}, Username: ${username}`);
            const user = auth.currentUser;
            if (!user || !currentRoomId) {
                console.log('No user or roomId, skipping stats update');
                return;
            }
            try {
                const userDocRef = doc(db, 'users', user.uid);
                const userDoc = await getDoc(userDocRef);
                let stats = userDoc.data()?.stats || { wins: 0, losses: 0, ties: 0 };
                console.log('Current stats:', stats);
                if (result === currentPlayer) {
                    showMessage('You won!', 'success');
                    stats.wins += 1;
                } else if (result === 'tie') {
                    showMessage('Game tied!', 'success');
                    stats.ties += 1;
                } else {
                    showMessage(`${opponentUsername} won!`, 'error');
                    stats.losses += 1;
                }
                console.log('Updating stats to:', stats);
                await updateDoc(userDocRef, { stats });
                // Update profile card
                if (profileWins) profileWins.textContent = stats.wins;
                if (profileLosses) profileLosses.textContent = stats.losses;
                if (profileTies) profileTies.textContent = stats.ties;
                await updateDoc(doc(db, 'rooms', currentRoomId), { status: 'finished', winner: result });
                setTimeout(() => {
                    cleanupGame();
                    showContainer(dashboard);
                }, 2000);
            } catch (error) {
                console.error('Game end error:', error.code, error.message);
                showMessage(`Error updating stats: ${error.message}`, 'error');
            }
        }

        // Cleanup Game
        function cleanupGame() {
            console.log('Cleaning up game');
            if (currentRoomId) {
                updateDoc(doc(db, 'rooms', currentRoomId), { status: 'closed' }).catch(error => {
                    console.error('Cleanup error:', error);
                });
                currentRoomId = null;
            }
            if (unsubscribeRoom) {
                unsubscribeRoom();
                unsubscribeRoom = null;
            }
            currentPlayer = null;
            opponentUsername = null;
            if (gameBoard) {
                gameBoard.querySelectorAll('.cell').forEach(cell => {
                    cell.textContent = '';
                    cell.className = 'cell';
                });
            }
            if (gameStatus) gameStatus.textContent = 'Waiting for opponent...';
            if (roomIdDisplay) roomIdDisplay.textContent = '';
            if (playersDisplay) playersDisplay.textContent = '';
            if (auth.currentUser) {
                showContainer(dashboard);
            } else {
                showContainer(authContainer);
            }
        }

        // Leave Room
        if (leaveRoom) {
            leaveRoom.addEventListener('click', () => {
                console.log('Leave room clicked');
                showMessage('Left room', 'success');
                cleanupGame();
            });
        }

        // Profile Settings (Placeholder)
        if (profileSettings) {
            profileSettings.addEventListener('click', () => {
                console.log('Profile settings clicked');
                showMessage('Settings not implemented yet.', 'error');
                // Future: Open settings modal to edit username, etc.
            });
        }

        // Auth State Listener - Display Username and Stats
        onAuthStateChanged(auth, async user => {
            console.log('Auth state changed:', user ? `User: ${user.uid}` : 'No user');
            if (user) {
                showContainer(dashboard);
                try {
                    const userDoc = await getDoc(doc(db, 'users', user.uid));
                    const username = userDoc.exists() && userDoc.data().username ? userDoc.data().username : 'Player';
                    const stats = userDoc.exists() && userDoc.data().stats ? userDoc.data().stats : { wins: 0, losses: 0, ties: 0 };
                    if (userDisplay) userDisplay.textContent = username;
                    if (profileUsername) profileUsername.textContent = username;
                    if (profileWins) profileWins.textContent = stats.wins;
                    if (profileLosses) profileWins.textContent = stats.losses;
                    if (profileTies) profileTies.textContent = stats.ties;
                    if (usernameInput) {
                        usernameInput.placeholder = userDoc.exists() && userDoc.data().username ? 
                            `Current: ${userDoc.data().username}` : 'Set Username';
                    }
                } catch (error) {
                    console.error('Fetch user data error:', error);
                    showMessage(`Error fetching user data: ${error.message}`, 'error');
                    if (userDisplay) userDisplay.textContent = 'Player';
                    if (profileUsername) profileUsername.textContent = 'Player';
                    if (profileWins) profileWins.textContent = '0';
                    if (profileLosses) profileLosses.textContent = '0';
                    if (profileTies) profileTies.textContent = '0';
                }
            } else {
                showContainer(authContainer);
                if (userDisplay) userDisplay.textContent = '';
                if (profileUsername) profileUsername.textContent = 'Guest';
                if (profileWins) profileWins.textContent = '0';
                if (profileLosses) profileLosses.textContent = '0';
                if (profileTies) profileTies.textContent = '0';
                if (usernameInput) usernameInput.placeholder = 'Set Username';
                cleanupGame();
            }
        });

        // Logout
        if (logoutButton) {
            logoutButton.addEventListener('click', async () => {
                console.log('Logout button clicked');
                try {
                    await signOut(auth);
                    showMessage('Logged out successfully!', 'success');
                    showContainer(authContainer);
                    cleanupGame();
                } catch (error) {
                    console.error('Logout error:', error.code, error.message);
                    showMessage(`Error: ${error.message}`, 'error');
                }
            });
        }
    </script>
</body>
</html>
